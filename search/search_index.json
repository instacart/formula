{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A Kotlin framework for managing state and side effects. It is inspired by MVU(model, view, update) architecture and best of functional, declarative and reactive patterns. It enables building deterministic, composable, testable applications. Quick example To demonstrate some of the concepts we will make a simple counter application. It shows the current count and has two buttons to increment and decrement it. One of the best practises when working with Formula is to first think what the UI needs for rendering and what actions the user will be able to take. This concept is called a RenderModel and is represented by a Kotlin data class. Render Model Render Model is an immutable representation of your view. It will be used to update Android views. Typically, it will also contain event listeners that will be invoked when user interacts with the UI. data class CounterRenderModel ( val count : String , val onDecrement : Listener < Unit > , val onIncrement : Listener < Unit > , ) Once we define a Render Model, we can create a RenderView which is responsible for taking a RenderModel and applying it to Android Views. Render View Render View is an interface which is responsible for applying RenderModel to Android Views. This interface requires us to provide a render implementation by creating a Renderer . Renderer is a class that has an internal mechanism that checks the previous Render Model applied and only re-renders if it has changed. class CounterRenderView ( root : ViewGroup ): RenderView < CounterRenderModel > { private val decrementButton : Button = root . findViewById ( R . id . decrement_button ) private val incrementButton : Button = root . findViewById ( R . id . increment_button ) private val countTextView : TextView = root . findViewById ( R . id . count_text_view ) override val render : Renderer < CounterRenderModel > = Renderer { model -> countTextView . text = model . count decrementButton . setOnClickListener { model . onDecrement () } incrementButton . setOnClickListener { model . onIncrement () } } } We now defined a single entry-point to our rendering (this makes debugging issues a lot easier). Anytime you need to update UI, just set a new Render Model. renderView . render ( renderModel ) Now that we have our rendering logic setup, let's define how we create the Render Model and handle user events. To have a dynamic UI that changes as user interacts with it requires some sort of state. State State is a Kotlin data class that contains all the necessary information/data to render your view. In our counter example, we need to keep track of the current count. data class CounterState ( val count : Int ) Given that this is a simple state, you could also use Int directly. Formula Formula is responsible for creating the Render Model. It can define an internal State class and respond to various events by transitioning to a new state. class CounterFormula : Formula < Unit , CounterState , CounterRenderModel > { override fun initialState ( input : Unit ): CounterState = CounterState ( count = 0 ) override fun evaluate ( input : Unit , state : CounterState , context : FormulaContext < Int > ): Evaluation < CounterRenderModel > { val count = state . count return Evaluation ( output = CounterRenderModel ( title = \"Count: $ count \" , onDecrement = context . onEvent { transition ( state . copy ( count = count - 1 )) }, onIncrement = context . onEvent { transition ( state . copy ( count = count + 1 )) } ) ) } } The most important part is the Formula.evaluate function. It gives us the current State and expects an Evaluation<RenderModel> back. Any time we transition to a new state, evaluate is called again and new Render Model is created. There is also a special object called FormulaContext being passed. Formula Context allows us to respond to events by declaring transitions. We use context.onEvent for both onIncrement and onDecrement . Let's look at one of these functions closer. onDecrement = context . onEvent { transition ( state . copy ( count = count - 1 )) } In response to the decrement event, we take the current count and subtract 1 from it. Then, we call transition method to create Transition<CounterState> object which we return. If you notice, our logic currently allows user to decrement to a number below 0. We can update the transition logic to prevent this. onDecrement = context . onEvent { if ( count == 0 ) { none () } else { transition ( state . copy ( count = count - 1 )) } } The listener block uses a DSL to provide access to Transition.Factory which has the transition and none utility functions (take a look at that class for other utility functions). Now that we defined our state management, let's connect it to our RenderView . Using Formula Formula is agnostic to other layers of abstraction. It can be used within activity or a fragment. You can convert Formula to an RxJava 3 Observable by using start extension function. val formula = CounterFormula () val state : Observable < CounterRenderModel > = formula . toObservable ( input = Unit ) Ideally, it would be placed within a surface that survives configuration changes such as Android Components ViewModel. In this example, we will use Formula Android module. For using Formula with AndroidX ViewModel, take a look at AndroidX Guide . Let's first define our Activity. class MyActivity : FormulaAppCompatActivity () { private lateinit var counterRenderView : CounterRenderView override fun onCreate ( state : Bundle?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) counterRenderView = CounterRenderView ( findViewById ( R . id . counter )) } fun render ( model : CounterRenderModel ) { counterRenderView . render ( model ) } } Now, let's connect CounterFormula to MyActivity.render function. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity < MyActivity > { store ( streams = { val formula = CounterFormula () update ( formula . toObservable (), MyActivity :: render ) } ) } } } } And that's it. You can see the full sample here . To learn more about Formula Android module see Formula Android Guide . Download Add the library to your list of dependencies: dependencies { implementation 'com.instacart.formula:formula-rxjava3:0.7.1' implementation 'com.instacart.formula:formula-android:0.7.1' } Inspiration Formula would not have been possible without ideas from other projects such as Elm Cycle.js React / Redux Mobius Square Workflows License The Clear BSD License Copyright (c) 2022 Maplebear Inc. dba Instacart All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted (subject to the limitations in the disclaimer below) provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of Maplebear Inc. dba Instacart nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Overview"},{"location":"#quick-example","text":"To demonstrate some of the concepts we will make a simple counter application. It shows the current count and has two buttons to increment and decrement it. One of the best practises when working with Formula is to first think what the UI needs for rendering and what actions the user will be able to take. This concept is called a RenderModel and is represented by a Kotlin data class.","title":"Quick example"},{"location":"#render-model","text":"Render Model is an immutable representation of your view. It will be used to update Android views. Typically, it will also contain event listeners that will be invoked when user interacts with the UI. data class CounterRenderModel ( val count : String , val onDecrement : Listener < Unit > , val onIncrement : Listener < Unit > , ) Once we define a Render Model, we can create a RenderView which is responsible for taking a RenderModel and applying it to Android Views.","title":"Render Model"},{"location":"#render-view","text":"Render View is an interface which is responsible for applying RenderModel to Android Views. This interface requires us to provide a render implementation by creating a Renderer . Renderer is a class that has an internal mechanism that checks the previous Render Model applied and only re-renders if it has changed. class CounterRenderView ( root : ViewGroup ): RenderView < CounterRenderModel > { private val decrementButton : Button = root . findViewById ( R . id . decrement_button ) private val incrementButton : Button = root . findViewById ( R . id . increment_button ) private val countTextView : TextView = root . findViewById ( R . id . count_text_view ) override val render : Renderer < CounterRenderModel > = Renderer { model -> countTextView . text = model . count decrementButton . setOnClickListener { model . onDecrement () } incrementButton . setOnClickListener { model . onIncrement () } } } We now defined a single entry-point to our rendering (this makes debugging issues a lot easier). Anytime you need to update UI, just set a new Render Model. renderView . render ( renderModel ) Now that we have our rendering logic setup, let's define how we create the Render Model and handle user events. To have a dynamic UI that changes as user interacts with it requires some sort of state.","title":"Render View"},{"location":"#state","text":"State is a Kotlin data class that contains all the necessary information/data to render your view. In our counter example, we need to keep track of the current count. data class CounterState ( val count : Int ) Given that this is a simple state, you could also use Int directly.","title":"State"},{"location":"#formula","text":"Formula is responsible for creating the Render Model. It can define an internal State class and respond to various events by transitioning to a new state. class CounterFormula : Formula < Unit , CounterState , CounterRenderModel > { override fun initialState ( input : Unit ): CounterState = CounterState ( count = 0 ) override fun evaluate ( input : Unit , state : CounterState , context : FormulaContext < Int > ): Evaluation < CounterRenderModel > { val count = state . count return Evaluation ( output = CounterRenderModel ( title = \"Count: $ count \" , onDecrement = context . onEvent { transition ( state . copy ( count = count - 1 )) }, onIncrement = context . onEvent { transition ( state . copy ( count = count + 1 )) } ) ) } } The most important part is the Formula.evaluate function. It gives us the current State and expects an Evaluation<RenderModel> back. Any time we transition to a new state, evaluate is called again and new Render Model is created. There is also a special object called FormulaContext being passed. Formula Context allows us to respond to events by declaring transitions. We use context.onEvent for both onIncrement and onDecrement . Let's look at one of these functions closer. onDecrement = context . onEvent { transition ( state . copy ( count = count - 1 )) } In response to the decrement event, we take the current count and subtract 1 from it. Then, we call transition method to create Transition<CounterState> object which we return. If you notice, our logic currently allows user to decrement to a number below 0. We can update the transition logic to prevent this. onDecrement = context . onEvent { if ( count == 0 ) { none () } else { transition ( state . copy ( count = count - 1 )) } } The listener block uses a DSL to provide access to Transition.Factory which has the transition and none utility functions (take a look at that class for other utility functions). Now that we defined our state management, let's connect it to our RenderView .","title":"Formula"},{"location":"#using-formula","text":"Formula is agnostic to other layers of abstraction. It can be used within activity or a fragment. You can convert Formula to an RxJava 3 Observable by using start extension function. val formula = CounterFormula () val state : Observable < CounterRenderModel > = formula . toObservable ( input = Unit ) Ideally, it would be placed within a surface that survives configuration changes such as Android Components ViewModel. In this example, we will use Formula Android module. For using Formula with AndroidX ViewModel, take a look at AndroidX Guide . Let's first define our Activity. class MyActivity : FormulaAppCompatActivity () { private lateinit var counterRenderView : CounterRenderView override fun onCreate ( state : Bundle?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) counterRenderView = CounterRenderView ( findViewById ( R . id . counter )) } fun render ( model : CounterRenderModel ) { counterRenderView . render ( model ) } } Now, let's connect CounterFormula to MyActivity.render function. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity < MyActivity > { store ( streams = { val formula = CounterFormula () update ( formula . toObservable (), MyActivity :: render ) } ) } } } } And that's it. You can see the full sample here . To learn more about Formula Android module see Formula Android Guide .","title":"Using Formula"},{"location":"#download","text":"Add the library to your list of dependencies: dependencies { implementation 'com.instacart.formula:formula-rxjava3:0.7.1' implementation 'com.instacart.formula:formula-android:0.7.1' }","title":"Download"},{"location":"#inspiration","text":"Formula would not have been possible without ideas from other projects such as Elm Cycle.js React / Redux Mobius Square Workflows","title":"Inspiration"},{"location":"#license","text":"The Clear BSD License Copyright (c) 2022 Maplebear Inc. dba Instacart All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted (subject to the limitations in the disclaimer below) provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of Maplebear Inc. dba Instacart nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"CONTRIBUTING/","text":"Contributing In an effort to keep the library small and stable, please keep contributions limited to bug fixes, documentation improvements, and test improvements. Issues that are tagged as help wanted are great issues to get started contributing to Formula. If you have a new feature idea, please create an enhancement request issue on GitHub so it can be discussed or created in an external library. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code passes all tests by running ./test.sh . Modified from OkHttp's Contributing section.","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"In an effort to keep the library small and stable, please keep contributions limited to bug fixes, documentation improvements, and test improvements. Issues that are tagged as help wanted are great issues to get started contributing to Formula. If you have a new feature idea, please create an enhancement request issue on GitHub so it can be discussed or created in an external library. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code passes all tests by running ./test.sh . Modified from OkHttp's Contributing section.","title":"Contributing"},{"location":"Declarative-API/","text":"Formula is a mix of functional, reactive and declarative programming. One aspect that might seem quite unusual is the way that it handles asynchronous actions such as RxJava observables, Kotlin Flows, etc. Most developers are used to explicitly managing subscription lifecycle. val fetchUserObservable = repository . fetchUser () disposables += fetchUserObservable . subscribe { userResult -> // Do something } Formula does things a bit differently. It manages the lifecycle of the asynchronous actions for you. Instead of manually subscribing and unsubscribing, you define the conditions for which the asynchronous action should run and the listener which handles events produced by the action. val fetchUserAction = RxAction . fromObservable { repository . fetchUser () } fetchUserAction . onEvent { userResult -> // Do something } The logic looks very similar to the first option, but the key difference here is that Observable.subscribe hasn't run yet - the execution is deferred. It might not be clear why this is useful just from this example, but deferring execution allows us to provide a declarative API. For example, we can add conditional logic to only fetch user when user id is set. if ( state . userId != null ) { val fetchUserAction = RxAction . fromObservable { repository . fetchUser ( state . userId ) } fetchUserAction . onEvent { userResult -> // Do something with the result } } What if we want to fetch user information only after user clicks on some button to enable this. We can just expand on the conditional logic. if ( state . isUserFetchEnabled && state . userId != null ) { // Logic here is the same as the previous example } Here, we don\u2019t care what controls isUserFetchEnabled boolean. Formula will start execution when these conditions are met and will dispose of the action if state.isUserFetchedEnabled becomes false again. What if for some unusual reason the userId could change and we would want to refetch? We can define this behavior using key parameter if ( state . isUserFetchEnabled && state . userId != null ) { val fetchUserAction = RxAction . fromObservable ( key = state . userId ) { repository . fetchUser ( state . userId ) } fetchUserAction . onEvent { userResult -> // Do something with the result } } To understand how all this works, we will make some simplified assumptions about Formula APIs: Each Formula will define an immutable State data class. We use State object in the evaluate(state: State) function which defines the Pair<UIModel, Actions> Any time there is a State change, the Formula runtime will call evaluate again. In code, this might look like this val actionCache : MutableMap < Key , RunningAction > = mutableMapOf () fun onStateChanged ( state : State ) { val ( uiModel , actions ) = formula . evaluate ( state ) // Stop actions actionCache . forEach { ( key , runningAction ) -> if ( ! actions . contains ( key )) { actionCache . remove ( key ) runningAction . stop () } } // Start actions actions . forEach { action -> if ( ! actionCache . contains ( key )) { actionCache [ key ] = action . start () } } } It's worth mentioning that this is an approximate and not the actual implementation. Within our assumptions we didn't discuss formula inputs (passed to configure Formula) and child formulas (enables re-use and composition) which also have an affect on evaluation. Similarly, to how we used State to control the lifecycle of the action, we can use formula input or child formula outputs. To expand on the previous assumptions, let's define how Input interacts with Formula . Input is passed by the outside world to configure Formula instance. Similarly to State : Input is usually an immutable data class We use Input object in the evaluate(input, state) function to create Pair<UIModel, Actions> Any time there is an Input change, the Formula runtime will call evaluate again. This means that similarly to State , we can also use Input to define action conditions. if ( input . userId != null ) { val fetchUserAction = RxAction . fromObservable { repository . fetchUser ( input . userId ) } fetchUserAction . onEvent { userResult -> // Do something with the result } }","title":"Declarative API"},{"location":"Formula-Android/","text":"Formula Android The Android module provides a declarative API to connect reactive state management to Android Fragments. This module has been designed for gradual adoption. You can use as much or as little of it as you like. Some of the goals for this module are: - Use a single RxJava stream to drive the UI. - Separate state management from Android UI lifecycle. - Ability to group multiple fragments into a flow and share state between them. - Type-safe and scoped fragment event handling. (Avoid casting activity to a listener) Using Fragments This module provides an API to connect state management and view rendering logic to Android fragments. For this example, we will connect CounterRenderView and CounterFormula from the main getting started guide . Define a fragment key Fragment key is used to instantiate FormulaFragment and to identify which FeatureFactory to use. You can also use it to add arguments that the fragment instance needs. /** * Fragment key has to provide Parcelable implementation because it is passed * to the fragment as an argument. * * Read more about Parcelize: https://kotlinlang.org/docs/tutorials/android-plugin.html */ @Parcelize data class CounterKey ( override val tag : String = \"counter\" ) : FragmentKey Define a feature factory A feature factory creates the state observable and a view factory for a fragment. To continue our example, we define a CounterFeatureFactory which will handle CounterKey fragments. class CounterFeatureFactory : FeatureFactory < Any , CounterKey > { override fun initialize ( dependencies : Any , key : CounterKey ): Feature <*> { val counterFormula = CounterFormula () return Feature ( state = counterFormula . toObservable (), viewFactory = CounterViewFactory () ) } } // View factory which uses XML layout resource. class CounterViewFactory : LayoutViewFactory < CounterRenderModel > ( R . layout . counter ) { override fun ViewInstance . create (): FeatureView < CounterRenderModel > { // We use [ViewInstance.view] to access the inflated view val counterView = CounterRenderView ( view ) // We create a [FeatureView] by passing a [RenderView] return featureView ( counterView ) } } We now need to register our feature factory with the activity in which the counter will be shown. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { store { bind ( CounterFeatureFactory ()) } } } } } Use formula fragment The only thing left is navigating to this screen. We create FormulaFragment instance using our CounterKey and use fragment transactions to add it. class MyActivity : FormulaAppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . my_activity ) if ( savedInstanceState == null ) { val key = CounterKey () val fragment = FormulaFragment . newInstance ( key ) // Add the fragment using the fragment transaction API. supportFragmentManager . beginTransaction () . add ( R . id . activity_content , fragment , key . tag ) . commit () } } } If your Activity has another base class, you can just copy logic from FormulaAppCompatActivity into your Activity . And that's it Formula takes care of the rest. This is how the state observable works: When FormulaFragment is added, we instantiate and subscribe to the state observable. When FormulaFragment is removed, we destroy the state observable. The state management observable continues to run during configuration changes or if you navigate to another fragment. Passing arguments to a fragment Arguments can be passed using fragment key class. For example, we want to pass initial count value to the CounterFormula used in the previous examples. To accomplish that, let's update the CounterKey . @Parcelize data class CounterKey ( val initialCount : Int = 0 , override val tag : String = \"counter\" ) : FragmentKey You can access the CounterKey within CounterFeatureFactory class CounterFeatureFactory : FeatureFactory < Any , CounterKey > { override fun initialize ( dependencies : Any , key : CounterKey ): Feature <*> { val initialCount = key . initialCount val counterFormula = CounterFormula ( initialCount ) ... } } Fragment Event Handling Very frequently we need to pass events from a fragment to the parent/activity which trigger things like navigation. Let's say we want to add the following behaviors to the previous counter example: show a toast notification when user increments to 10 navigate to a new \"victory\" screen when user increments to 100. First, let's define a class that defines our events. data class CounterEventRouter ( val onToastNotification : ( String ) -> Unit , val onVictoryReached : () -> Unit ) We can now request this dependency within our feature factory class CounterFeatureFactory : FeatureFactory < Dependencies , CounterKey > { // We can ask for dependencies from the parent using an interface. interface Dependencies { fun counterEventRouter (): CounterEventRouter } override fun initialize ( dependencies : Dependencies , key : CounterKey ): Feature <*> { val counterEventRouter = dependencies . counterEventRouter () // We can pass the event router to the counter formula. val counterFormula = CounterFormula ( counterEventRouter ) return ... } } To provide dependencies, the parent component needs to extend CounterFeatureFactory.Dependencies class MyActivityComponent ( private val store : ActivityStoreContext < MyActivity > ) : CounterFeatureFactory . Dependencies { override fun counterEventRouter (): CounterEventRouter { return CounterEventRouter ( onToastNotification = this :: showToast , onVictoryReached = { // VictoryFragmentKey implementation is left to readers imagination. val key = VictoryFragmentKey () navigateTo ( key ) } ) } private fun showToast ( message : String ) { store . send { Toast . makeText ( this , message , Toast . LENGTH_LONG ). show () } } private fun navigateTo ( key : FragmentKey ) { store . send { // Sample fragment transaction val fragment = FormulaFragment . newInstance ( key ) supportFragmentManager . beginTransaction () . add ( R . id . activity_content , fragment , key . tag ) . addToBackStack ( null ) . commit () } } } To pass this component to feature factories, we need to update the configuration that lives within our Application . class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { store ( MyActivityComponent ( this )) { bind ( CounterFeatureFactory ()) } } } } } Handling back button events To override how the back button works for a particular navigation destination, your render model needs to implement BackCallback interface. data class FormRenderModel ( private val confirmBeforeExiting : Boolean , private val confirmUserWantsToExit : () -> Unit ): BackCallback { fun onBackPressed (): Boolean { // Check if we need to override back handling if ( confirmBeforeExiting ) { confirmUserWantsToExit () return true } // Use default behavior (which closes the screen) return false } } Your Activity needs to call FormulaAndroid.onBackPressed() . It will check if your current screen implements BackCallback and will invoke it. class MyActivity : FragmentActivity () { override fun onBackPressed () { if ( ! FormulaAndroid . onBackPressed ( this )) { super . onBackPressed () } } } This is already in place for you if you use FormulaAppCompatActivity . Fragment flow factory A flow factory groups multiple fragments and allows to share state, routers, action handlers and other dependencies between them. It has two generic parameters: Dependencies that the parent needs to provide. FlowComponent that will be shared with all features defined by this flow. For this example, let's say we are building authentication for our app. The backend provides view information such as the hints we should show for email or password fields. We want to only fetch this data once and share it between the login and sign up fragments. Let's say our repository class looks something like this class AuthRepo ( private val retrofit : Retrofit ) { // Backend provides data that helps us render auth pages. data class PageResponse ( val emailHint : String , val passwordHint : String , ) // This will check if we have in-memory response and // return that, otherwise make a fresh call. fun pageEvents (): Observable < AuthPageResponse > { ... } } As you can see above, this repository class needs a Retrofit instance to function. We can define the dependencies we need using an interface. interface Dependencies { fun retrofit (): Retrofit } Let's create our flow component. In a real application, component would usually be implemented by DI framework such as Dagger . class AuthFlowComponent ( private val dependencies : Dependencies ) { // Auth repo needs to be a singleton so we instantiate // this once when component is created. val authRepo = AuthRepo ( dependencies . retrofit ()) } We can now define AuthFlowFactory . A flow factory has two methods: createComponent - we create AuthFlowComponent here createFlow - we register feature factories that are part of our flow class AuthFlowFactory : FlowFactory < Dependencies , AuthFlowComponent > { interface Dependencies { fun retrofit (): Retrofit } class AuthFlowComponent ( private val dependencies : Dependencies ) { val authRepo = AuthRepo ( dependencies . retrofit ()) } override fun createComponent ( dependencies : Dependencies ): DisposableScope < AuthFlowComponent > { val flowComponent = AuthFlowComponent ( dependencies ) return DisposableScope ( flowComponent , onDispose = { // Here you can clear observables and dispose of other resources // that the component needed }) } override fun createFlow (): Flow < AuthFlowComponent > { return Flow . build { bind ( AuthRootFeatureFactory ()) bind ( LoginFeatureFactory ()) bind ( SignUpFeatureFactory ()) } } } Before we integrate AuthFlowFactory within our application, we need to update our app component to provide dependencies. class AppComponent () : AuthFlowFactory . Dependencies { override fun retrofit (): Retrofit { return ... } } Now that we have our dependencies configured, let's bind the flow factory to our activity store val appComponent = AppComponent () FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { store ( appComponent ) { bind ( AuthFlowFactory ()) } } } Formula calls createComponent when a formula fragment handled by createFlow is added. This component lives as long as there are any formula fragments defined by createFlow alive. The component is disposed once the last formula fragment is removed. Activity state management One of the goals of Formula is to make doing the right thing easy. As part of that we wanted to provide an easy way for state streams to survive configuration changes by default. Let's define a basic activity that has a renderTime method. class MyActivity : FormulaAppCompatActivity () { fun renderTime ( time : String ) { // implementation left to the reader } } To connect an RxJava Observable to renderTime , we define streams parameter which expects a Disposable back. Within this method you can subscribe to any number of RxJava streams. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity < MyActivity > { store ( streams = { // You can subscribe to your RxJava streams here. val timerState = Observable . interval ( 0 , 1 , TimeUnit . SECONDS ) . observeOn ( AndroidSchedulers . mainThread ()) . map { time -> \" $ time seconds\" } // update ensures that if configuration changes happen then // we send the last state to the new activity instance. update ( timerState , MyActivity :: renderTime ) } ) } } } } You might be confused about the update function called there. It is provided within the context of streams function using Kotlin receiver parameter StreamConfigurator . The update function ensures that state changes only arrive after Activity has started and that last state is applied if Activity is re-created due to configuration changes. It returns a Disposable . Managing dependencies Managing dependencies in Formula is very easy. In the function that instantiates the ActivityStore for your activity, you can create your activity specific dependencies or Dagger components. These objects will survive configuration changes. class MyApp : Application () { override fun onCreate () { super . onCreate () val appComponent : AppComponent = ... FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { // This component will survive configuration changes. val activityComponent = appComponent . createMyActivityComponent () store { } } } } } To inject the activity or create activity dependencies that don't survive configuration changes such as ones that need direct activity reference, you can use configureActivity callback. val appComponent : AppComponent = ... FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { // This component will survive configuration changes. val activityComponent = appComponent . createMyActivityComponent () store ( configureActivity = { // in this callback `this` is the instance of MyActivity // so we can use it to inject dependencies activityComponent . inject ( this ) // Or you can use setters to provide dependencies to your activity. // This dependency object won't survive configuration changes. val dependency = MyActivityDependency ( activity = this ) this . setDependency ( dependency ) } ) } }","title":"Formula Android"},{"location":"Formula-Android/#formula-android","text":"The Android module provides a declarative API to connect reactive state management to Android Fragments. This module has been designed for gradual adoption. You can use as much or as little of it as you like. Some of the goals for this module are: - Use a single RxJava stream to drive the UI. - Separate state management from Android UI lifecycle. - Ability to group multiple fragments into a flow and share state between them. - Type-safe and scoped fragment event handling. (Avoid casting activity to a listener)","title":"Formula Android"},{"location":"Formula-Android/#using-fragments","text":"This module provides an API to connect state management and view rendering logic to Android fragments. For this example, we will connect CounterRenderView and CounterFormula from the main getting started guide .","title":"Using Fragments"},{"location":"Formula-Android/#define-a-fragment-key","text":"Fragment key is used to instantiate FormulaFragment and to identify which FeatureFactory to use. You can also use it to add arguments that the fragment instance needs. /** * Fragment key has to provide Parcelable implementation because it is passed * to the fragment as an argument. * * Read more about Parcelize: https://kotlinlang.org/docs/tutorials/android-plugin.html */ @Parcelize data class CounterKey ( override val tag : String = \"counter\" ) : FragmentKey","title":"Define a fragment key"},{"location":"Formula-Android/#define-a-feature-factory","text":"A feature factory creates the state observable and a view factory for a fragment. To continue our example, we define a CounterFeatureFactory which will handle CounterKey fragments. class CounterFeatureFactory : FeatureFactory < Any , CounterKey > { override fun initialize ( dependencies : Any , key : CounterKey ): Feature <*> { val counterFormula = CounterFormula () return Feature ( state = counterFormula . toObservable (), viewFactory = CounterViewFactory () ) } } // View factory which uses XML layout resource. class CounterViewFactory : LayoutViewFactory < CounterRenderModel > ( R . layout . counter ) { override fun ViewInstance . create (): FeatureView < CounterRenderModel > { // We use [ViewInstance.view] to access the inflated view val counterView = CounterRenderView ( view ) // We create a [FeatureView] by passing a [RenderView] return featureView ( counterView ) } } We now need to register our feature factory with the activity in which the counter will be shown. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { store { bind ( CounterFeatureFactory ()) } } } } }","title":"Define a feature factory"},{"location":"Formula-Android/#use-formula-fragment","text":"The only thing left is navigating to this screen. We create FormulaFragment instance using our CounterKey and use fragment transactions to add it. class MyActivity : FormulaAppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . my_activity ) if ( savedInstanceState == null ) { val key = CounterKey () val fragment = FormulaFragment . newInstance ( key ) // Add the fragment using the fragment transaction API. supportFragmentManager . beginTransaction () . add ( R . id . activity_content , fragment , key . tag ) . commit () } } } If your Activity has another base class, you can just copy logic from FormulaAppCompatActivity into your Activity .","title":"Use formula fragment"},{"location":"Formula-Android/#and-thats-it","text":"Formula takes care of the rest. This is how the state observable works: When FormulaFragment is added, we instantiate and subscribe to the state observable. When FormulaFragment is removed, we destroy the state observable. The state management observable continues to run during configuration changes or if you navigate to another fragment.","title":"And that's it"},{"location":"Formula-Android/#passing-arguments-to-a-fragment","text":"Arguments can be passed using fragment key class. For example, we want to pass initial count value to the CounterFormula used in the previous examples. To accomplish that, let's update the CounterKey . @Parcelize data class CounterKey ( val initialCount : Int = 0 , override val tag : String = \"counter\" ) : FragmentKey You can access the CounterKey within CounterFeatureFactory class CounterFeatureFactory : FeatureFactory < Any , CounterKey > { override fun initialize ( dependencies : Any , key : CounterKey ): Feature <*> { val initialCount = key . initialCount val counterFormula = CounterFormula ( initialCount ) ... } }","title":"Passing arguments to a fragment"},{"location":"Formula-Android/#fragment-event-handling","text":"Very frequently we need to pass events from a fragment to the parent/activity which trigger things like navigation. Let's say we want to add the following behaviors to the previous counter example: show a toast notification when user increments to 10 navigate to a new \"victory\" screen when user increments to 100. First, let's define a class that defines our events. data class CounterEventRouter ( val onToastNotification : ( String ) -> Unit , val onVictoryReached : () -> Unit ) We can now request this dependency within our feature factory class CounterFeatureFactory : FeatureFactory < Dependencies , CounterKey > { // We can ask for dependencies from the parent using an interface. interface Dependencies { fun counterEventRouter (): CounterEventRouter } override fun initialize ( dependencies : Dependencies , key : CounterKey ): Feature <*> { val counterEventRouter = dependencies . counterEventRouter () // We can pass the event router to the counter formula. val counterFormula = CounterFormula ( counterEventRouter ) return ... } } To provide dependencies, the parent component needs to extend CounterFeatureFactory.Dependencies class MyActivityComponent ( private val store : ActivityStoreContext < MyActivity > ) : CounterFeatureFactory . Dependencies { override fun counterEventRouter (): CounterEventRouter { return CounterEventRouter ( onToastNotification = this :: showToast , onVictoryReached = { // VictoryFragmentKey implementation is left to readers imagination. val key = VictoryFragmentKey () navigateTo ( key ) } ) } private fun showToast ( message : String ) { store . send { Toast . makeText ( this , message , Toast . LENGTH_LONG ). show () } } private fun navigateTo ( key : FragmentKey ) { store . send { // Sample fragment transaction val fragment = FormulaFragment . newInstance ( key ) supportFragmentManager . beginTransaction () . add ( R . id . activity_content , fragment , key . tag ) . addToBackStack ( null ) . commit () } } } To pass this component to feature factories, we need to update the configuration that lives within our Application . class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { store ( MyActivityComponent ( this )) { bind ( CounterFeatureFactory ()) } } } } }","title":"Fragment Event Handling"},{"location":"Formula-Android/#handling-back-button-events","text":"To override how the back button works for a particular navigation destination, your render model needs to implement BackCallback interface. data class FormRenderModel ( private val confirmBeforeExiting : Boolean , private val confirmUserWantsToExit : () -> Unit ): BackCallback { fun onBackPressed (): Boolean { // Check if we need to override back handling if ( confirmBeforeExiting ) { confirmUserWantsToExit () return true } // Use default behavior (which closes the screen) return false } } Your Activity needs to call FormulaAndroid.onBackPressed() . It will check if your current screen implements BackCallback and will invoke it. class MyActivity : FragmentActivity () { override fun onBackPressed () { if ( ! FormulaAndroid . onBackPressed ( this )) { super . onBackPressed () } } } This is already in place for you if you use FormulaAppCompatActivity .","title":"Handling back button events"},{"location":"Formula-Android/#fragment-flow-factory","text":"A flow factory groups multiple fragments and allows to share state, routers, action handlers and other dependencies between them. It has two generic parameters: Dependencies that the parent needs to provide. FlowComponent that will be shared with all features defined by this flow. For this example, let's say we are building authentication for our app. The backend provides view information such as the hints we should show for email or password fields. We want to only fetch this data once and share it between the login and sign up fragments. Let's say our repository class looks something like this class AuthRepo ( private val retrofit : Retrofit ) { // Backend provides data that helps us render auth pages. data class PageResponse ( val emailHint : String , val passwordHint : String , ) // This will check if we have in-memory response and // return that, otherwise make a fresh call. fun pageEvents (): Observable < AuthPageResponse > { ... } } As you can see above, this repository class needs a Retrofit instance to function. We can define the dependencies we need using an interface. interface Dependencies { fun retrofit (): Retrofit } Let's create our flow component. In a real application, component would usually be implemented by DI framework such as Dagger . class AuthFlowComponent ( private val dependencies : Dependencies ) { // Auth repo needs to be a singleton so we instantiate // this once when component is created. val authRepo = AuthRepo ( dependencies . retrofit ()) } We can now define AuthFlowFactory . A flow factory has two methods: createComponent - we create AuthFlowComponent here createFlow - we register feature factories that are part of our flow class AuthFlowFactory : FlowFactory < Dependencies , AuthFlowComponent > { interface Dependencies { fun retrofit (): Retrofit } class AuthFlowComponent ( private val dependencies : Dependencies ) { val authRepo = AuthRepo ( dependencies . retrofit ()) } override fun createComponent ( dependencies : Dependencies ): DisposableScope < AuthFlowComponent > { val flowComponent = AuthFlowComponent ( dependencies ) return DisposableScope ( flowComponent , onDispose = { // Here you can clear observables and dispose of other resources // that the component needed }) } override fun createFlow (): Flow < AuthFlowComponent > { return Flow . build { bind ( AuthRootFeatureFactory ()) bind ( LoginFeatureFactory ()) bind ( SignUpFeatureFactory ()) } } } Before we integrate AuthFlowFactory within our application, we need to update our app component to provide dependencies. class AppComponent () : AuthFlowFactory . Dependencies { override fun retrofit (): Retrofit { return ... } } Now that we have our dependencies configured, let's bind the flow factory to our activity store val appComponent = AppComponent () FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { store ( appComponent ) { bind ( AuthFlowFactory ()) } } } Formula calls createComponent when a formula fragment handled by createFlow is added. This component lives as long as there are any formula fragments defined by createFlow alive. The component is disposed once the last formula fragment is removed.","title":"Fragment flow factory"},{"location":"Formula-Android/#activity-state-management","text":"One of the goals of Formula is to make doing the right thing easy. As part of that we wanted to provide an easy way for state streams to survive configuration changes by default. Let's define a basic activity that has a renderTime method. class MyActivity : FormulaAppCompatActivity () { fun renderTime ( time : String ) { // implementation left to the reader } } To connect an RxJava Observable to renderTime , we define streams parameter which expects a Disposable back. Within this method you can subscribe to any number of RxJava streams. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity < MyActivity > { store ( streams = { // You can subscribe to your RxJava streams here. val timerState = Observable . interval ( 0 , 1 , TimeUnit . SECONDS ) . observeOn ( AndroidSchedulers . mainThread ()) . map { time -> \" $ time seconds\" } // update ensures that if configuration changes happen then // we send the last state to the new activity instance. update ( timerState , MyActivity :: renderTime ) } ) } } } } You might be confused about the update function called there. It is provided within the context of streams function using Kotlin receiver parameter StreamConfigurator . The update function ensures that state changes only arrive after Activity has started and that last state is applied if Activity is re-created due to configuration changes. It returns a Disposable .","title":"Activity state management"},{"location":"Formula-Android/#managing-dependencies","text":"Managing dependencies in Formula is very easy. In the function that instantiates the ActivityStore for your activity, you can create your activity specific dependencies or Dagger components. These objects will survive configuration changes. class MyApp : Application () { override fun onCreate () { super . onCreate () val appComponent : AppComponent = ... FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { // This component will survive configuration changes. val activityComponent = appComponent . createMyActivityComponent () store { } } } } } To inject the activity or create activity dependencies that don't survive configuration changes such as ones that need direct activity reference, you can use configureActivity callback. val appComponent : AppComponent = ... FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { // This component will survive configuration changes. val activityComponent = appComponent . createMyActivityComponent () store ( configureActivity = { // in this callback `this` is the instance of MyActivity // so we can use it to inject dependencies activityComponent . inject ( this ) // Or you can use setters to provide dependencies to your activity. // This dependency object won't survive configuration changes. val dependency = MyActivityDependency ( activity = this ) this . setDependency ( dependency ) } ) } }","title":"Managing dependencies"},{"location":"State-Render-Model-Separation/","text":"Why state & render model separation This allows us to keep the view very stupid. Let's say we have a state class such as this data class State ( val userInfo : Lce < UserInfo > , val saveRequest : Lce < SaveResponse >? = null ) // UI layer now has to contain logic to process these properties. fun render ( state : State ) { saveButton . isEnabled = state . userInfo . hasData () && ( state . saveRequest == null && ! state . saveRequest . isLoading ()) } To avoid having such logic in the view, we have created the RenderModel concept. data class RenderModel ( val isSaveEnabled : Boolean ) The logic where we do this transformation is encapsulated in the RenderModelGenerator. class MyRenderModelGenerator : RenderModelGenerator < State , RenderModel > { override fun toRenderModel ( state : State ): RenderModel { return RenderModel ( isSaveEnabled = state . userInfo . hasData () && ( state . saveRequest == null && ! state . saveRequest . isLoading ()) ) } } Now, the UI would receive a RenderModel instead of State. Also, we can now easily unit test that logic separately from the view.","title":"State Render Model Separation"},{"location":"State-Render-Model-Separation/#why-state-render-model-separation","text":"This allows us to keep the view very stupid. Let's say we have a state class such as this data class State ( val userInfo : Lce < UserInfo > , val saveRequest : Lce < SaveResponse >? = null ) // UI layer now has to contain logic to process these properties. fun render ( state : State ) { saveButton . isEnabled = state . userInfo . hasData () && ( state . saveRequest == null && ! state . saveRequest . isLoading ()) } To avoid having such logic in the view, we have created the RenderModel concept. data class RenderModel ( val isSaveEnabled : Boolean ) The logic where we do this transformation is encapsulated in the RenderModelGenerator. class MyRenderModelGenerator : RenderModelGenerator < State , RenderModel > { override fun toRenderModel ( state : State ): RenderModel { return RenderModel ( isSaveEnabled = state . userInfo . hasData () && ( state . saveRequest == null && ! state . saveRequest . isLoading ()) ) } } Now, the UI would receive a RenderModel instead of State. Also, we can now easily unit test that logic separately from the view.","title":"Why state &amp; render model separation"},{"location":"async_events/","text":"It's worth reading Event Handling section first given that there is a lot of overlap. To show how Formula handles asynchronous events, we'll use a task app example. Let's say we have a task repository that exposes an RxJava Observable<List<Task>> . interface TaskRepo { fun getTaskList (): Observable < List < Task >> } All asynchronous events have to be declared within Formula.evaluate function. override fun Snapshot < Input , State > . evaluate (): Evaluation < Output > { return Evaluation ( output = createRenderModel ( state . taskList ), // All async events need to be declared within \"context.actions\" block. actions = context . actions { // Convert RxJava observable to a Formula Action. val taskAction = RxAction . fromObservable { taskRepo . getTaskList () } // Tell Formula that you want to listen to these events taskAction . onEvent { newTaskList -> // update our state transition ( state . copy ( taskList = newTaskList )) } } ) } Formula uses a Action interface to define an asynchronous event producers/sources. interface Action < Event > { fun start ( send : ( Event ) -> Unit ): Cancelable? } In this example we used an RxAction.fromObservable to convert from an Observable to a Action instance. Instead of us subscribing to the observable directly, the runtime manages the subscriptions for us. It will subscribe the first time the action is returned as part of evaluation output and unsubscribe when our Formula is removed or if we don't return it anymore. For example, it is okay to have conditional logic. context . actions { if ( state . locationTrackingEnabled ) { val locationAction = RxAction . fromObservable { locationManager . updates () } events ( locationAction ) { event -> transition ( state . copy ( location = event . location )) } } } If state.locationTrackingEnabled changes from true to false , we won't return this Action anymore and the runtime will unsubscribe. Fetching data Let's say we need to fetch a task that has a specific task id . interface TaskRepo { fun fetchTask ( taskId : String ): Observable < Task > } Using TaskRepo directly: class TaskFormula ( val taskRepo : TaskRepo ): Formula { data class Input ( val taskId : String ) data class State ( val task : Task? = null ) override fun Snapshot < Input , State > . evaluate (): Evaluation < Output > { return Evaluation ( actions = context . actions { val fetchTask = RxAction . fromObservable ( key = input . taskId ) { taskRepo . fetchTask ( input . taskId ) } events ( fetchTask ) { taskResponse -> transition ( state . copy ( task = taskResponse )) } } ) } } The key parameter enables us to distinguish between different actions. If input.taskId changes, we will cancel the currently running Action and start a new one. Note: we are not handling errors in this example. The best practice is to emit errors as data using the onNext instead of emitting them through onError. Extending Action Interface If you need to use a different mechanism for asynchronous events, you can extend Action interface. interface Action < Event > { fun start ( send : ( Event ) -> Unit ): Cancelable? } For example, let's say we want to track network status (I'm going to use mock network status APIs). class GetNetworkStatusAction ( val manager : NetworkStatusManager ) : Action < NetworkStatus > { override fun start ( send : ( NetworkStatus ) -> Unit ): Cancelable? { val listener = object : NetworkStatusListener { override fun onNetworkStatusChanged ( status : NetworkStatus ) = send ( status ) } manager . addNetworkStatusListener ( listener ) return Cancelable { manager . removeNetworkStatusListener ( listener ) } } } We can now hook this up within our Formula: class MyFormula ( val getNetworkStatusAction : GetNetworkStatusAction ): Formula < Input , State , Output > { override fun Snapshot < Input , State > . evaluate (): Evaluation < Output > { return Evaluation ( actions = context . actions { getNetworkStatusAction . onEvent { status -> val updated = status . copy ( isOnline = status . isOnline ) transition ( updated ) } } ) } }","title":"Asynchronous Events"},{"location":"async_events/#fetching-data","text":"Let's say we need to fetch a task that has a specific task id . interface TaskRepo { fun fetchTask ( taskId : String ): Observable < Task > } Using TaskRepo directly: class TaskFormula ( val taskRepo : TaskRepo ): Formula { data class Input ( val taskId : String ) data class State ( val task : Task? = null ) override fun Snapshot < Input , State > . evaluate (): Evaluation < Output > { return Evaluation ( actions = context . actions { val fetchTask = RxAction . fromObservable ( key = input . taskId ) { taskRepo . fetchTask ( input . taskId ) } events ( fetchTask ) { taskResponse -> transition ( state . copy ( task = taskResponse )) } } ) } } The key parameter enables us to distinguish between different actions. If input.taskId changes, we will cancel the currently running Action and start a new one. Note: we are not handling errors in this example. The best practice is to emit errors as data using the onNext instead of emitting them through onError.","title":"Fetching data"},{"location":"async_events/#extending-action-interface","text":"If you need to use a different mechanism for asynchronous events, you can extend Action interface. interface Action < Event > { fun start ( send : ( Event ) -> Unit ): Cancelable? } For example, let's say we want to track network status (I'm going to use mock network status APIs). class GetNetworkStatusAction ( val manager : NetworkStatusManager ) : Action < NetworkStatus > { override fun start ( send : ( NetworkStatus ) -> Unit ): Cancelable? { val listener = object : NetworkStatusListener { override fun onNetworkStatusChanged ( status : NetworkStatus ) = send ( status ) } manager . addNetworkStatusListener ( listener ) return Cancelable { manager . removeNetworkStatusListener ( listener ) } } } We can now hook this up within our Formula: class MyFormula ( val getNetworkStatusAction : GetNetworkStatusAction ): Formula < Input , State , Output > { override fun Snapshot < Input , State > . evaluate (): Evaluation < Output > { return Evaluation ( actions = context . actions { getNetworkStatusAction . onEvent { status -> val updated = status . copy ( isOnline = status . isOnline ) transition ( updated ) } } ) } }","title":"Extending Action Interface"},{"location":"composition/","text":"Composing Render models Render Models are meant to be composable. You can build bigger Render Models from smaller Render Models. data class CheckboxRenderModel ( val text : String , val isChecked : Boolean , val onToggle : () -> Unit ) data class NotificationSettingsRenderModel ( val messagePushNotification : CheckboxRenderModel , val promotionalPushNotifications : CheckboxRenderModel , val marketingEmailNotifications : CheckboxRenderModel , val saveSettingsButton : FooterButtonRenderModel ) You can also do the same in your Render View layer. class CheckboxRenderView ( root : View ) : RenderView < CheckboxRenderModel > { private val checkbox : Checkbox = root . findViewById ( R . id . checkbox ) override val render : Renderer < CheckboxRenderModel > = Renderer { model -> checkbox . text = model . title checkbox . isChecked = model . isChecked checkbox . setOnCheckedListener { model . onToggle () } } } class NotificationSettingsRenderView ( root : View ) : RenderView < NotificationSettingsRenderModel > { private val messagePushNotification = CheckboxRenderView ( root . findViewById ( R . id . message_push_checkbox )) private val promotionalPushNotifications = CheckboxRenderView ( root . findViewById ( R . id . promotional_push_checkbox )) private val marketingEmailNotifications = CheckboxRenderView ( root . findViewById ( R . id . marketing_email_checkbox )) private val saveButton = FooterButtonRenderView ( root . findViewById ( R . id . save_button )) override val render : Renderer < NotificationSettingsRenderModel > = Renderer { model -> messagePushNotification . render ( model . messagePushNotification ) promotionalPushNotifications . render ( model . promotionalPushNotifications ) marketingEmailNotifications . render ( model . marketingEmailNotifications ) saveButton . render ( model . saveSettingsButton ) } } Composing formulas You can pass other formulas through the constructor class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula <> Use FormulaContext.child within Formula.evaluate to hook them up. val listRenderModel = context . child ( listFormula ) . input { ListInput ( items = state . items , onItemSelected = context . onEvent < ItemSelected > { event -> // you can respond to child event } } Here is a more complete example: class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula < Unit , MyState , MainRenderModel > { override fun Snapshot < Unit , MyState > . evaluate (): Evaluation < MainRenderModel > { // \"context.child\" returns a RenderModel val listRenderModel = context . child ( listFormula , createListInput ( state )) val headerRenderModel = context . child ( headerFormula , createHeaderInput ( state )) // We can make decisions using the current `state` about // what children to show val dialog = if ( state . showDialog ) { context . child ( dialogFormula , Unit ) } else { null } return Evaluation ( output = MainRenderModel ( header = headerRenderModel , list = listRenderModel , dialog = dialog ) ) } }","title":"Composition"},{"location":"composition/#composing-render-models","text":"Render Models are meant to be composable. You can build bigger Render Models from smaller Render Models. data class CheckboxRenderModel ( val text : String , val isChecked : Boolean , val onToggle : () -> Unit ) data class NotificationSettingsRenderModel ( val messagePushNotification : CheckboxRenderModel , val promotionalPushNotifications : CheckboxRenderModel , val marketingEmailNotifications : CheckboxRenderModel , val saveSettingsButton : FooterButtonRenderModel ) You can also do the same in your Render View layer. class CheckboxRenderView ( root : View ) : RenderView < CheckboxRenderModel > { private val checkbox : Checkbox = root . findViewById ( R . id . checkbox ) override val render : Renderer < CheckboxRenderModel > = Renderer { model -> checkbox . text = model . title checkbox . isChecked = model . isChecked checkbox . setOnCheckedListener { model . onToggle () } } } class NotificationSettingsRenderView ( root : View ) : RenderView < NotificationSettingsRenderModel > { private val messagePushNotification = CheckboxRenderView ( root . findViewById ( R . id . message_push_checkbox )) private val promotionalPushNotifications = CheckboxRenderView ( root . findViewById ( R . id . promotional_push_checkbox )) private val marketingEmailNotifications = CheckboxRenderView ( root . findViewById ( R . id . marketing_email_checkbox )) private val saveButton = FooterButtonRenderView ( root . findViewById ( R . id . save_button )) override val render : Renderer < NotificationSettingsRenderModel > = Renderer { model -> messagePushNotification . render ( model . messagePushNotification ) promotionalPushNotifications . render ( model . promotionalPushNotifications ) marketingEmailNotifications . render ( model . marketingEmailNotifications ) saveButton . render ( model . saveSettingsButton ) } }","title":"Composing Render models"},{"location":"composition/#composing-formulas","text":"You can pass other formulas through the constructor class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula <> Use FormulaContext.child within Formula.evaluate to hook them up. val listRenderModel = context . child ( listFormula ) . input { ListInput ( items = state . items , onItemSelected = context . onEvent < ItemSelected > { event -> // you can respond to child event } } Here is a more complete example: class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula < Unit , MyState , MainRenderModel > { override fun Snapshot < Unit , MyState > . evaluate (): Evaluation < MainRenderModel > { // \"context.child\" returns a RenderModel val listRenderModel = context . child ( listFormula , createListInput ( state )) val headerRenderModel = context . child ( headerFormula , createHeaderInput ( state )) // We can make decisions using the current `state` about // what children to show val dialog = if ( state . showDialog ) { context . child ( dialogFormula , Unit ) } else { null } return Evaluation ( output = MainRenderModel ( header = headerRenderModel , list = listRenderModel , dialog = dialog ) ) } }","title":"Composing formulas"},{"location":"diffing/","text":"TODO Diffing Given that we recompute everything with each state change, there is an internal diffing mechanism with Formula. This mechanism ensures that: 1. RxJava observables are only subscribed to once. 2. Children state is persisted across every processing pass.","title":"Diffing"},{"location":"diffing/#diffing","text":"Given that we recompute everything with each state change, there is an internal diffing mechanism with Formula. This mechanism ensures that: 1. RxJava observables are only subscribed to once. 2. Children state is persisted across every processing pass.","title":"Diffing"},{"location":"events/","text":"Event handling in Formula is based on event listeners. A listener is just a function that is called when an event happens and could be described by a simple (Event) -> Unit function type. We pass listeners to other parts of the codebase such as the view layer by adding the listener to the Render Model . UI Events To handle UI events, declare a Listener on the Render Model for each type of UI event you care about. data class FormRenderModel ( // A listener where event contains no information (We use kotlin.Unit type). val onSaveSelected : Listener < Unit > , // A listener where name string is passed as part of the event. val onNameChanged : Listener < String > , ) To create a listener use FormulaContext.onEvent . Note: All listeners should be created within Formula.evaluate block. override fun Snapshot < Input , State > . evaluate (): Evaluation < FormRenderModel > { return Evaluation ( output = FormRenderModel ( onNameChanged = context . onEvent < String > { newName -> // Use \"newName\" to perform a transition transition ( state . copy ( name = newName )) }, onSaveSelected = context . onEvent < Unit > { // No state change, performing side-effects. transition { userService . updateName ( state . name ) analytics . trackNameUpdated ( state . name ) } } ) ) } This example is dense, but it shows almost every kind of scenario. Let's go over it. To create a listener, we pass a function that returns a Transition<State> . Formula uses transitions to update internal state and/or perform side-effects to other components. Listeners are scoped to the current state. Any time we transition to a new state, evaluate is called again and the listeners are recreated. // Updating state context . onEvent { newName : String -> // We use kotlin data class copy function // to create a new state with new name transition ( state . copy ( name = newName )) } // Updating onSaveSelected to include validation context . onEvent { if ( state . name . isBlank ()) { // A transition which performs a side-effect. transition { input . showNotification ( \"Name cannot be empty!\" ) } } else { // No state change, performing side-effects as part of the transition transition { userService . updateName ( state . name ) analytics . trackNameUpdated ( state . name ) } } } To ensure safe execution, all side-effects should be performed within transition {} block which will be executed after the state change is performed. Sending messages to the parent To pass events to the parent, first define the listener on the Formula.Input class. data class ItemListInput ( val onItemSelected : Listener < ItemId > , ) Also, lets make sure that Input type is declared at the top of our formula . class ItemListFormula () : Formula < ItemListInput , ..., ... > Now, we can use the input passed to us in Formula.evaluate to communicate with the parent. override fun evaluate ( input : ItemListInput , state , context ): ... { return Evaluation ( output = state . items . map { item -> context . key ( item . id ) { ItemRow ( name = item . name , onClick = context . onEvent { // Notifying parent that item was selected. transition { input . onItemSelected ( item . id ) } } ) } } ) } Formula events There are a few events that every formula can listen to and respond. Evaluation ( output = ..., actions = context . actions { // Performs a side effect when formula is initialized Action . onInit (). onEvent { transition { analytics . trackScreenOpen () } } // Performs a side effect when formula is terminated Action . onTerminate (). onEvent { transition { analytics . trackClose () } } // Performs a side-effect when data changes Action . onData ( state . itemId ). onEvent { // This will call api.fetchItem for each unique itemId transition { api . fetchItem ( state . itemId ) } } } ) Formula retains listeners Listeners retain equality across re-evaluation (such as state changes). The first time formula requests a listener, we create it and persist it in the map. Subsequent calls will re-use this instance. The instance is disabled and removed when your formula is removed or if you don't request this listener within Formula.evaluate block. By default, we generate a key for each listener based on the listener type. Usually, this is an anonymous class which is associated with the position in code where it is called. There are a couple of cases when this is not sufficient and you need to explicitly provide a unique key . Case 1: Declaring listeners within a loop For example, if you are mapping list of items and creating a listener within the map function. // This will not work unless your list of items never changes (removal of item or position change). ItemListRenderModel ( items = state . items . map { item -> ItemRenderModel ( name = item . name , onSelected = context . onEvent { // perform a transition } ) } ) To fix it, you should wrap ItemRenderModel creation block in context.key where you pass it an item id . context . key ( item . id ) { ItemRenderModel ( name = item . name , onSelected = context . onEvent { // perform a transition } ) } Case 2: Delegating to another function There is an issue with listeners when passing FormulaContext to another function. Let's say you have a function that takes FormulaContext and creates a ChildRenderModel. fun createChildRenderModel ( context : FormulaContext < ... > ): ChildRenderModel { return ChildRenderModel ( onClick = context . onEvent {} ) } There is no problem calling it once, but there will be key collisions if you call it multiple times: RenderModel ( // First child is created with no problem first = createChildRenderModel ( context ), // Calling it again will crash second = createChildRenderModel ( context ) ) To fix it, wrap createChildRenderModel with context.key block. RenderModel ( first = context . key ( \"first\" ) { createChildRenderModel ( context ) }, second = context . key ( \"second\" ) { createChildRenderModel ( context ) } )","title":"Event Handling"},{"location":"events/#ui-events","text":"To handle UI events, declare a Listener on the Render Model for each type of UI event you care about. data class FormRenderModel ( // A listener where event contains no information (We use kotlin.Unit type). val onSaveSelected : Listener < Unit > , // A listener where name string is passed as part of the event. val onNameChanged : Listener < String > , ) To create a listener use FormulaContext.onEvent . Note: All listeners should be created within Formula.evaluate block. override fun Snapshot < Input , State > . evaluate (): Evaluation < FormRenderModel > { return Evaluation ( output = FormRenderModel ( onNameChanged = context . onEvent < String > { newName -> // Use \"newName\" to perform a transition transition ( state . copy ( name = newName )) }, onSaveSelected = context . onEvent < Unit > { // No state change, performing side-effects. transition { userService . updateName ( state . name ) analytics . trackNameUpdated ( state . name ) } } ) ) } This example is dense, but it shows almost every kind of scenario. Let's go over it. To create a listener, we pass a function that returns a Transition<State> . Formula uses transitions to update internal state and/or perform side-effects to other components. Listeners are scoped to the current state. Any time we transition to a new state, evaluate is called again and the listeners are recreated. // Updating state context . onEvent { newName : String -> // We use kotlin data class copy function // to create a new state with new name transition ( state . copy ( name = newName )) } // Updating onSaveSelected to include validation context . onEvent { if ( state . name . isBlank ()) { // A transition which performs a side-effect. transition { input . showNotification ( \"Name cannot be empty!\" ) } } else { // No state change, performing side-effects as part of the transition transition { userService . updateName ( state . name ) analytics . trackNameUpdated ( state . name ) } } } To ensure safe execution, all side-effects should be performed within transition {} block which will be executed after the state change is performed.","title":"UI Events"},{"location":"events/#sending-messages-to-the-parent","text":"To pass events to the parent, first define the listener on the Formula.Input class. data class ItemListInput ( val onItemSelected : Listener < ItemId > , ) Also, lets make sure that Input type is declared at the top of our formula . class ItemListFormula () : Formula < ItemListInput , ..., ... > Now, we can use the input passed to us in Formula.evaluate to communicate with the parent. override fun evaluate ( input : ItemListInput , state , context ): ... { return Evaluation ( output = state . items . map { item -> context . key ( item . id ) { ItemRow ( name = item . name , onClick = context . onEvent { // Notifying parent that item was selected. transition { input . onItemSelected ( item . id ) } } ) } } ) }","title":"Sending messages to the parent"},{"location":"events/#formula-events","text":"There are a few events that every formula can listen to and respond. Evaluation ( output = ..., actions = context . actions { // Performs a side effect when formula is initialized Action . onInit (). onEvent { transition { analytics . trackScreenOpen () } } // Performs a side effect when formula is terminated Action . onTerminate (). onEvent { transition { analytics . trackClose () } } // Performs a side-effect when data changes Action . onData ( state . itemId ). onEvent { // This will call api.fetchItem for each unique itemId transition { api . fetchItem ( state . itemId ) } } } )","title":"Formula events"},{"location":"events/#formula-retains-listeners","text":"Listeners retain equality across re-evaluation (such as state changes). The first time formula requests a listener, we create it and persist it in the map. Subsequent calls will re-use this instance. The instance is disabled and removed when your formula is removed or if you don't request this listener within Formula.evaluate block. By default, we generate a key for each listener based on the listener type. Usually, this is an anonymous class which is associated with the position in code where it is called. There are a couple of cases when this is not sufficient and you need to explicitly provide a unique key .","title":"Formula retains listeners"},{"location":"events/#case-1-declaring-listeners-within-a-loop","text":"For example, if you are mapping list of items and creating a listener within the map function. // This will not work unless your list of items never changes (removal of item or position change). ItemListRenderModel ( items = state . items . map { item -> ItemRenderModel ( name = item . name , onSelected = context . onEvent { // perform a transition } ) } ) To fix it, you should wrap ItemRenderModel creation block in context.key where you pass it an item id . context . key ( item . id ) { ItemRenderModel ( name = item . name , onSelected = context . onEvent { // perform a transition } ) }","title":"Case 1: Declaring listeners within a loop"},{"location":"events/#case-2-delegating-to-another-function","text":"There is an issue with listeners when passing FormulaContext to another function. Let's say you have a function that takes FormulaContext and creates a ChildRenderModel. fun createChildRenderModel ( context : FormulaContext < ... > ): ChildRenderModel { return ChildRenderModel ( onClick = context . onEvent {} ) } There is no problem calling it once, but there will be key collisions if you call it multiple times: RenderModel ( // First child is created with no problem first = createChildRenderModel ( context ), // Calling it again will crash second = createChildRenderModel ( context ) ) To fix it, wrap createChildRenderModel with context.key block. RenderModel ( first = context . key ( \"first\" ) { createChildRenderModel ( context ) }, second = context . key ( \"second\" ) { createChildRenderModel ( context ) } )","title":"Case 2: Delegating to another function"},{"location":"faq/","text":"Only thread that created it can trigger transitions The state management should be initialized on the main thread and all the transitions should also happen on the main thread. You will get the following exception if that is not the case. Caused by: java.lang.IllegalStateException: Only thread that created it can trigger transitions. Expected: main, Was: Network 1 Transition already happened. After each transition, formula is re-evaluated and new event listeners are created. If you use an old listener you will see the following exception. Caused by: java.lang.IllegalStateException: Transition already happened. This is using old event listener: $it. Listener is already defined. TODO.. After evaluation finished If a onEvent is called after the Formula evaluation is finished, you will see this exception. Caused by: java.lang.IllegalStateException: Cannot call this after evaluation finished. This means that you called onEvent after Formula.evalute already returned Evaluation object. This can happen when you are calling onEvent within transition block. This is not allowed because your listener would be scoped to a stale state instance. Instead, you should create your listeners within the evaluate function itself, passing the data you might be using from the onEvent into the State defined for that Formula. For example, instead of: class TaskDetailFormula @Inject constructor( private val repo: TasksRepo, ) : Formula<TaskDetailFormula.Input, TaskDetailFormula.State, TaskDetailRenderModel> { data class Input( val taskId: String ) data class State( val task: TaskDetailRenderModel? = null ) override fun initialState(input: Input) = State() override fun Snapshot<Input, State>.evaluate(): Evaluation<TaskDetailRenderModel?> { return Evaluation( output = state.task, actions = context.actions { RxAction.fromObservable { repo.fetchTask(input.taskId) }.onEvent { task -> val renderModel = TaskDetailRenderModel( title = task.title, // Don't do: calling context.onEvent within \"onEvent\" will cause a crash described above onDeleteSelected = context.onEvent { ... } ) transition(state.copy(task = renderModel)) } } ) } } which the render model and then stores it in the State , we would store the fetched task from the RxAction in the state and then construct the render model in the evaluation function itself: class TaskDetailFormula @Inject constructor( private val repo: TasksRepo, ) : Formula<TaskDetailFormula.Input, TaskDetailFormula.State, TaskDetailRenderModel> { data class Input( val taskId: String ) data class State( val task: Task? = null ) override fun initialState(input: Input) = State() override fun Snapshot<Input, State>.evaluate(): Evaluation<TaskDetailRenderModel?> { // Note that this is correct because the render model and therefore listener is constructed // within `evaluate` instead of within `onEvent` val renderModel = state.task?.let { TaskDetailRenderModel( title = it.title, onDeleteSelected = context.onEvent { ... } ) } return Evaluation( output = renderModel, actions = context.actions { RxAction.fromObservable { repo.fetchTask(input.taskId) }.onEvent { task -> transition(state.copy(task = renderModel)) } } ) } } Notice that the render model is no longer stored in the state, but instead constructed on each call to evaluate so that the listeners are never stale.","title":"FAQ"},{"location":"faq/#only-thread-that-created-it-can-trigger-transitions","text":"The state management should be initialized on the main thread and all the transitions should also happen on the main thread. You will get the following exception if that is not the case. Caused by: java.lang.IllegalStateException: Only thread that created it can trigger transitions. Expected: main, Was: Network 1","title":"Only thread that created it can trigger transitions"},{"location":"faq/#transition-already-happened","text":"After each transition, formula is re-evaluated and new event listeners are created. If you use an old listener you will see the following exception. Caused by: java.lang.IllegalStateException: Transition already happened. This is using old event listener: $it.","title":"Transition already happened."},{"location":"faq/#listener-is-already-defined","text":"TODO..","title":"Listener is already defined."},{"location":"faq/#after-evaluation-finished","text":"If a onEvent is called after the Formula evaluation is finished, you will see this exception. Caused by: java.lang.IllegalStateException: Cannot call this after evaluation finished. This means that you called onEvent after Formula.evalute already returned Evaluation object. This can happen when you are calling onEvent within transition block. This is not allowed because your listener would be scoped to a stale state instance. Instead, you should create your listeners within the evaluate function itself, passing the data you might be using from the onEvent into the State defined for that Formula. For example, instead of: class TaskDetailFormula @Inject constructor( private val repo: TasksRepo, ) : Formula<TaskDetailFormula.Input, TaskDetailFormula.State, TaskDetailRenderModel> { data class Input( val taskId: String ) data class State( val task: TaskDetailRenderModel? = null ) override fun initialState(input: Input) = State() override fun Snapshot<Input, State>.evaluate(): Evaluation<TaskDetailRenderModel?> { return Evaluation( output = state.task, actions = context.actions { RxAction.fromObservable { repo.fetchTask(input.taskId) }.onEvent { task -> val renderModel = TaskDetailRenderModel( title = task.title, // Don't do: calling context.onEvent within \"onEvent\" will cause a crash described above onDeleteSelected = context.onEvent { ... } ) transition(state.copy(task = renderModel)) } } ) } } which the render model and then stores it in the State , we would store the fetched task from the RxAction in the state and then construct the render model in the evaluation function itself: class TaskDetailFormula @Inject constructor( private val repo: TasksRepo, ) : Formula<TaskDetailFormula.Input, TaskDetailFormula.State, TaskDetailRenderModel> { data class Input( val taskId: String ) data class State( val task: Task? = null ) override fun initialState(input: Input) = State() override fun Snapshot<Input, State>.evaluate(): Evaluation<TaskDetailRenderModel?> { // Note that this is correct because the render model and therefore listener is constructed // within `evaluate` instead of within `onEvent` val renderModel = state.task?.let { TaskDetailRenderModel( title = it.title, onDeleteSelected = context.onEvent { ... } ) } return Evaluation( output = renderModel, actions = context.actions { RxAction.fromObservable { repo.fetchTask(input.taskId) }.onEvent { task -> transition(state.copy(task = renderModel)) } } ) } } Notice that the render model is no longer stored in the state, but instead constructed on each call to evaluate so that the listeners are never stale.","title":"After evaluation finished"},{"location":"input/","text":"Input is a Kotlin data class used to pass data and event listeners to the Formula instance. Let's say we need to pass an item id to ItemDetailFormula . class ItemDetailFormula () : Formula < ItemDetailFormula . Input , ..., ... > { // Input declaration data class Input ( val itemId : String ) // Use input to initialize state override fun initialState ( input : Input ): State = ... // Respond to Input changes. override fun onInputChanged ( oldInput : Input , input : Input , state : State ): State { // We can compare old and new inputs and create // a new state before `Formula.evaluate` is called. return state } // Using input within evaluate block override fun evaluate ( input : Input , state : .., context : .. ): Evaluation < ... > { val itemId = input . itemId // We can use the input here to fetch the item from the repo. } } To pass the input to ItemDetailFormula val itemDetailFormula : ItemDetailFormula = ... itemDetailFormula . toObservable ( ItemDetailFormula . Input ( itemId = \"1\" )) . subscribe { renderModel -> } You could also pass an Observable<ItemDetailFormula.Input> val itemDetailInput : Observable < ItemDetailFormula . Input > = ... itemDetailFormula . toObservable ( itemDetailInput ) . subscribe { renderModel -> } Equality Formula uses input equality to determine if it should re-evaluate. A parent can cause a child formula to re-evaluate by changing the input it passes. This will also trigger Formula.onInputChanged on the child formula. This is a desired behavior as we do want the child to react when the data that we pass changes. data class ItemInput ( val itemId : String ) Making Input a data class and passing data as part of its properties makes it easy to reason about its equality. In some cases though, we want to pass objects that don't have property based equality such as listeners or observables. Maintaining listener equality In many cases we want to pass listeners to listen to formula events. data class ItemListInput ( val onItemSelected : Listener < Item > ) Formula provides an easy way to maintain listener equality. Within your parent formula, you can use FormulaContext.onEvent to instantiate listeners. Don't: Don't instantiate functions within Formula.evaluate . override fun evaluate (...) { val itemListInput = ItemListInput ( onItemSelected = { analytics . track ( \"item_selected\" ) } ) } Do: Use onEvent override fun evaluate (...) { val itemListInput = ItemListInput ( onItemSelected = context . onEvent { _ -> transition { analytics . track ( \"item_selected\" ) } } ) } Do: Use already constructed listeners // Listener is constructed outside of the \"evaluate\" function block val onItemSelectedListener = Listener < Item > { } override fun evaluate (...): ... { val itemListInput = ItemListInput ( onItemSelected = onItemSelectedListener ) } Do: Delegate to parent input directly override fun evaluate ( input : Input , ...): ... { val itemListInput = ItemListInput ( onItemSelected = input . onItemSelected ) } Passing observables Observables have identity equality which make maintaining input equality a bit tricky. data class MyInput ( val eventObservable : Observable < Event > ) Don't: create a new observable within Formula.evaluate override fun evaluate (...) { val input = MyInput ( eventObservable = relay . map { Event () } ) } Do: create observable outside of Formula.evaluate private val eventObservable = relay . map { Event () } override fun evaluate (...) { val input = MyInput ( eventObservable = eventObservable ) } Do: use State to instantiate observable once data class State ( val eventObservable : Observable < Event > ) override fun initialState ( input : Input ) = State ( eventObservable = input . eventObservable . map { Event () } ) override fun evaluate (...) { val input = MyInput ( eventObservable = state . eventObservable ) } Don't: pass data observables data class Input ( val dataObservable : Observable < Data > ) Do: pass data directly data class Input ( val data : Data? )","title":"Using Input"},{"location":"input/#equality","text":"Formula uses input equality to determine if it should re-evaluate. A parent can cause a child formula to re-evaluate by changing the input it passes. This will also trigger Formula.onInputChanged on the child formula. This is a desired behavior as we do want the child to react when the data that we pass changes. data class ItemInput ( val itemId : String ) Making Input a data class and passing data as part of its properties makes it easy to reason about its equality. In some cases though, we want to pass objects that don't have property based equality such as listeners or observables.","title":"Equality"},{"location":"input/#maintaining-listener-equality","text":"In many cases we want to pass listeners to listen to formula events. data class ItemListInput ( val onItemSelected : Listener < Item > ) Formula provides an easy way to maintain listener equality. Within your parent formula, you can use FormulaContext.onEvent to instantiate listeners. Don't: Don't instantiate functions within Formula.evaluate . override fun evaluate (...) { val itemListInput = ItemListInput ( onItemSelected = { analytics . track ( \"item_selected\" ) } ) } Do: Use onEvent override fun evaluate (...) { val itemListInput = ItemListInput ( onItemSelected = context . onEvent { _ -> transition { analytics . track ( \"item_selected\" ) } } ) } Do: Use already constructed listeners // Listener is constructed outside of the \"evaluate\" function block val onItemSelectedListener = Listener < Item > { } override fun evaluate (...): ... { val itemListInput = ItemListInput ( onItemSelected = onItemSelectedListener ) } Do: Delegate to parent input directly override fun evaluate ( input : Input , ...): ... { val itemListInput = ItemListInput ( onItemSelected = input . onItemSelected ) }","title":"Maintaining listener equality"},{"location":"input/#passing-observables","text":"Observables have identity equality which make maintaining input equality a bit tricky. data class MyInput ( val eventObservable : Observable < Event > ) Don't: create a new observable within Formula.evaluate override fun evaluate (...) { val input = MyInput ( eventObservable = relay . map { Event () } ) } Do: create observable outside of Formula.evaluate private val eventObservable = relay . map { Event () } override fun evaluate (...) { val input = MyInput ( eventObservable = eventObservable ) } Do: use State to instantiate observable once data class State ( val eventObservable : Observable < Event > ) override fun initialState ( input : Input ) = State ( eventObservable = input . eventObservable . map { Event () } ) override fun evaluate (...) { val input = MyInput ( eventObservable = state . eventObservable ) } Don't: pass data observables data class Input ( val dataObservable : Observable < Data > ) Do: pass data directly data class Input ( val data : Data? )","title":"Passing observables"},{"location":"testing/","text":"Dependency To simplify testing your Formulas, use formula-test module. testImplementation 'com.instacart.formula:formula-test:{latest_version}' Basic example Use test extension to start testing your formula. Then, you can use output function to make assertions on the output or invoke event listeners. CounterFormula () . test () // Making assertion on the initial output . output { assertThat ( count ). isEqualTo ( \"Count: 0\" ) } // Invoking an event listener that live on the output. . output { onIncrement () } . output { onIncrement () } // Making assertion on final output . output { assertThat ( count ). isEqualTo ( \"Count: 2\" ) } Note: you can find the CounterFormula in the samples folder in the repository. Fakes and Mocks In some tests, we want to provide a fake/mock implementation of formula that can emit an output, check data passed by the parent or pass events back to the parent. Mockito example val testFormula = TestFormula < MyFormula . Input , MyFormula . Output > ( initialOutput = MyFormula . Output () ) // We only want to override the `implementation()` function and keep default `type()`. val formula = mock < MyFormula > ( defaultAnswer = CallsRealMethods ()) whenever ( formula . implementation ()). thenReturn ( testFormula ) Using interfaces and fakes in your testing interface MyFormula : IFormula < MyFormula . Input , MyFormula . Output > { class MyInput () class MyOutput () } // Test fake implementation class FakeMyFormula : MyFormula { val testFormula = TestFormula < MyFormula . Input , MyFormula . Output > ( initialOutput = MyFormula . Output () ) override fun implementation () = testFormula } Interacting with Test Formula val testFormula = TestFormula () // Assert on the data passed testFormula . input { assertThat ( this . id ). isEqualTo ( 1 ) } // Trigger an event testFormula . input { this . onTextChanged ( \"new text\" ) } // Emit a new output testFormula . output ( MyFormula . Output ())","title":"Testing"},{"location":"testing/#dependency","text":"To simplify testing your Formulas, use formula-test module. testImplementation 'com.instacart.formula:formula-test:{latest_version}'","title":"Dependency"},{"location":"testing/#basic-example","text":"Use test extension to start testing your formula. Then, you can use output function to make assertions on the output or invoke event listeners. CounterFormula () . test () // Making assertion on the initial output . output { assertThat ( count ). isEqualTo ( \"Count: 0\" ) } // Invoking an event listener that live on the output. . output { onIncrement () } . output { onIncrement () } // Making assertion on final output . output { assertThat ( count ). isEqualTo ( \"Count: 2\" ) } Note: you can find the CounterFormula in the samples folder in the repository.","title":"Basic example"},{"location":"testing/#fakes-and-mocks","text":"In some tests, we want to provide a fake/mock implementation of formula that can emit an output, check data passed by the parent or pass events back to the parent.","title":"Fakes and Mocks"},{"location":"testing/#mockito-example","text":"val testFormula = TestFormula < MyFormula . Input , MyFormula . Output > ( initialOutput = MyFormula . Output () ) // We only want to override the `implementation()` function and keep default `type()`. val formula = mock < MyFormula > ( defaultAnswer = CallsRealMethods ()) whenever ( formula . implementation ()). thenReturn ( testFormula )","title":"Mockito example"},{"location":"testing/#using-interfaces-and-fakes-in-your-testing","text":"interface MyFormula : IFormula < MyFormula . Input , MyFormula . Output > { class MyInput () class MyOutput () } // Test fake implementation class FakeMyFormula : MyFormula { val testFormula = TestFormula < MyFormula . Input , MyFormula . Output > ( initialOutput = MyFormula . Output () ) override fun implementation () = testFormula }","title":"Using interfaces and fakes in your testing"},{"location":"testing/#interacting-with-test-formula","text":"val testFormula = TestFormula () // Assert on the data passed testFormula . input { assertThat ( this . id ). isEqualTo ( 1 ) } // Trigger an event testFormula . input { this . onTextChanged ( \"new text\" ) } // Emit a new output testFormula . output ( MyFormula . Output ())","title":"Interacting with Test Formula"},{"location":"using_android_view_model/","text":"Define ViewModel which runs Formula.state stream until onCleared is called. class CounterViewModel () : ViewModel { private val formula = CounterFormula () private val disposables = CompositeDisposable () val renderModels = formula . toObservable (). replay ( 1 ). apply { connect { disposables . add ( it ) } } override fun onCleared () { super . onCleared () disposables . clear () } } In our activity, we then subscribe to the Render Model changes and pass them to the Render View. class MyActivity : AppCompatActivity () { private val disposables = CompositeDisposable () override fun onCreate ( state : Bundle?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) val renderView = CounterRenderView ( findViewById ( R . id . counter )) val viewModel = ViewModelProviders . of ( this ). get ( CounterViewModel :: class . java ) disposables . add ( viewModel . renderModels . subscribe ( renderView . render )) } override fun onDestroy () { disposables . clear () super . onDestroy () } }","title":"Using Android View Model"}]}
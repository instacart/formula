{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Formula is a functional reactive framework built in Kotlin for managing state and side effects. It enables building deterministic, composable, testable applications. Quick example To demonstrate some of the concepts we will make a simple counter application. It shows the current count and has two buttons to increment and decrement it. One of the best practises when working with Formula is to first think what the UI needs for rendering and what actions the user will be able to take. This concept is called a RenderModel and is represented by a Kotlin data class. Render Model Render Model is an immutable representation of your view. It will be used to update Android views. Typically, it will also contain callbacks that will be invoked when user interacts with the UI. data class CounterRenderModel ( val count : String , val onDecrement : () - Unit , val onIncrement : () - Unit ) Once we define a Render Model, we can create a RenderView which is responsible for taking a RenderModel and applying it to Android Views. Render View Render View is an interface that we extend. It requires us to create a Renderer that takes RenderModel and applies it to Android Views. Renderer has an internal mechanism that checks the previous Render Model applied and only re-renders if it has changed. class CounterRenderView ( root : ViewGroup ): RenderView CounterRenderModel { private val decrementButton : Button = root . findViewById ( R . id . decrement_button ) private val incrementButton : Button = root . findViewById ( R . id . increment_button ) private val countTextView : TextView = root . findViewById ( R . id . count_text_view ) override val renderer : Renderer CounterRenderModel = Renderer . create { model - countTextView . text = model . count decrementButton . setOnClickListener { model . onDecrement () } incrementButton . setOnClickListener { model . onIncrement () } } } We now defined a single entry-point to our rendering (this makes debugging issues a lot easier). Anytime you need to update UI, just set a new Render Model. renderView . renderer . render ( renderModel ) Now that we have our rendering logic setup, let's define how we create the Render Model and handle user events. To have a dynamic UI that changes as user interacts with it requires some sort of state. State State is a Kotlin data class that contains all the necessary information/data to render your view. In our counter example, we need to keep track of the current count. data class CounterState ( val count : Int ) Given that this is a simple state, you could also use Int directly. Formula Formula is responsible for creating the Render Model. It can define an internal State class and respond to various events by transitioning to a new state. class CounterFormula : Formula Unit , CounterState , CounterRenderModel { override fun initialState ( input : Unit ): Int = CounterState ( count = 0 ) override fun evaluate ( input : Unit , state : CounterState , context : FormulaContext Int ): Evaluation CounterRenderModel { val count = state . count return Evaluation ( renderModel = CounterRenderModel ( title = Count: $count , onDecrement = context . callback { transition ( state . copy ( count = count - 1 )) }, onIncrement = context . callback { transition ( state . copy ( count = count + 1 )) } ) ) } } The most import part is the Formula.evaluate function. It gives us the current State and expects an Evaluation RenderModel back. Any time we transition to a new state, evaluate is called again and new Render Model is created. There is also a special object called FormulaContext being passed. Formula Context allows us to respond to events by declaring transitions. We use context.callback for both onIncrement and onDecrement . Let's look at one of these functions closer. onDecrement = context . callback { transition ( state . copy ( count = count - 1 )) } In response to the decrement event, we take the current count and subtract 1 from it. Then, we call transition method to create Transition CounterState object which we return. If you notice, our logic currently allows user to decrement to a number below 0. We can update the transition logic to prevent this. onDecrement = context . callback { if ( count == 0 ) { none () } else { transition ( state . copy ( count = count - 1 )) } } The callback block uses a DSL to provide access to Transition.Factory which has the transition and none utility functions (take a look at that class for other utility functions). Now that we defined our state management, let's connect it to our RenderView . Using Formula Formula is agnostic to other layers of abstraction. It can be used within activity or a fragment. You can convert Formula to an RxJava2 Observable by using start extension function. val formula = CounterFormula () val state : Observable CounterRenderModel = formula . start ( input = Unit ) Ideally, it would be placed within a surface that survives configuration changes such as Android Components ViewModel. In this example, we will use Formula Android module. For using Formula with AndroidX ViewModel, take a look at AndroidX Guide . Let's first define our Activity. class MyActivity : FormulaAppCompatActivity () { private lateinit var counterRenderView : CounterRenderView override fun onCreate ( state : Bundle ?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) counterRenderView = CounterRenderView ( findViewById ( R . id . counter )) } fun render ( model : CounterRenderModel ) { counterRenderView . renderer . render ( model ) } } Now, let's connect CounterFormula to MyActivity.render function. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity MyActivity { store ( streams = { val formula = CounterFormula () update ( formula . start (), MyActivity :: render ) } ) } } } } And that's it. You can see the full sample here . To learn more about Formula Android module see Formula Android Guide . Download Add JitPack to your list of repositories: repositories { maven { url https://jitpack.io } } And add the library to your list of dependencies: dependencies { implementation com.github.instacart:formula:0.5.1 implementation com.github.instacart:formula-android:0.5.1 } Inspiration Formula would not have been possible without ideas from other projects such as Elm Cycle.js React / Redux Mobius Square Workflows License The Clear BSD License Copyright (c) 2019 Maplebear Inc. dba Instacart All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted (subject to the limitations in the disclaimer below) provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of Maplebear Inc. dba Instacart nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY S PATENT RIGHTS ARE GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Overview"},{"location":"#quick-example","text":"To demonstrate some of the concepts we will make a simple counter application. It shows the current count and has two buttons to increment and decrement it. One of the best practises when working with Formula is to first think what the UI needs for rendering and what actions the user will be able to take. This concept is called a RenderModel and is represented by a Kotlin data class.","title":"Quick example"},{"location":"#render-model","text":"Render Model is an immutable representation of your view. It will be used to update Android views. Typically, it will also contain callbacks that will be invoked when user interacts with the UI. data class CounterRenderModel ( val count : String , val onDecrement : () - Unit , val onIncrement : () - Unit ) Once we define a Render Model, we can create a RenderView which is responsible for taking a RenderModel and applying it to Android Views.","title":"Render Model"},{"location":"#render-view","text":"Render View is an interface that we extend. It requires us to create a Renderer that takes RenderModel and applies it to Android Views. Renderer has an internal mechanism that checks the previous Render Model applied and only re-renders if it has changed. class CounterRenderView ( root : ViewGroup ): RenderView CounterRenderModel { private val decrementButton : Button = root . findViewById ( R . id . decrement_button ) private val incrementButton : Button = root . findViewById ( R . id . increment_button ) private val countTextView : TextView = root . findViewById ( R . id . count_text_view ) override val renderer : Renderer CounterRenderModel = Renderer . create { model - countTextView . text = model . count decrementButton . setOnClickListener { model . onDecrement () } incrementButton . setOnClickListener { model . onIncrement () } } } We now defined a single entry-point to our rendering (this makes debugging issues a lot easier). Anytime you need to update UI, just set a new Render Model. renderView . renderer . render ( renderModel ) Now that we have our rendering logic setup, let's define how we create the Render Model and handle user events. To have a dynamic UI that changes as user interacts with it requires some sort of state.","title":"Render View"},{"location":"#state","text":"State is a Kotlin data class that contains all the necessary information/data to render your view. In our counter example, we need to keep track of the current count. data class CounterState ( val count : Int ) Given that this is a simple state, you could also use Int directly.","title":"State"},{"location":"#formula","text":"Formula is responsible for creating the Render Model. It can define an internal State class and respond to various events by transitioning to a new state. class CounterFormula : Formula Unit , CounterState , CounterRenderModel { override fun initialState ( input : Unit ): Int = CounterState ( count = 0 ) override fun evaluate ( input : Unit , state : CounterState , context : FormulaContext Int ): Evaluation CounterRenderModel { val count = state . count return Evaluation ( renderModel = CounterRenderModel ( title = Count: $count , onDecrement = context . callback { transition ( state . copy ( count = count - 1 )) }, onIncrement = context . callback { transition ( state . copy ( count = count + 1 )) } ) ) } } The most import part is the Formula.evaluate function. It gives us the current State and expects an Evaluation RenderModel back. Any time we transition to a new state, evaluate is called again and new Render Model is created. There is also a special object called FormulaContext being passed. Formula Context allows us to respond to events by declaring transitions. We use context.callback for both onIncrement and onDecrement . Let's look at one of these functions closer. onDecrement = context . callback { transition ( state . copy ( count = count - 1 )) } In response to the decrement event, we take the current count and subtract 1 from it. Then, we call transition method to create Transition CounterState object which we return. If you notice, our logic currently allows user to decrement to a number below 0. We can update the transition logic to prevent this. onDecrement = context . callback { if ( count == 0 ) { none () } else { transition ( state . copy ( count = count - 1 )) } } The callback block uses a DSL to provide access to Transition.Factory which has the transition and none utility functions (take a look at that class for other utility functions). Now that we defined our state management, let's connect it to our RenderView .","title":"Formula"},{"location":"#using-formula","text":"Formula is agnostic to other layers of abstraction. It can be used within activity or a fragment. You can convert Formula to an RxJava2 Observable by using start extension function. val formula = CounterFormula () val state : Observable CounterRenderModel = formula . start ( input = Unit ) Ideally, it would be placed within a surface that survives configuration changes such as Android Components ViewModel. In this example, we will use Formula Android module. For using Formula with AndroidX ViewModel, take a look at AndroidX Guide . Let's first define our Activity. class MyActivity : FormulaAppCompatActivity () { private lateinit var counterRenderView : CounterRenderView override fun onCreate ( state : Bundle ?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) counterRenderView = CounterRenderView ( findViewById ( R . id . counter )) } fun render ( model : CounterRenderModel ) { counterRenderView . renderer . render ( model ) } } Now, let's connect CounterFormula to MyActivity.render function. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity MyActivity { store ( streams = { val formula = CounterFormula () update ( formula . start (), MyActivity :: render ) } ) } } } } And that's it. You can see the full sample here . To learn more about Formula Android module see Formula Android Guide .","title":"Using Formula"},{"location":"#download","text":"Add JitPack to your list of repositories: repositories { maven { url https://jitpack.io } } And add the library to your list of dependencies: dependencies { implementation com.github.instacart:formula:0.5.1 implementation com.github.instacart:formula-android:0.5.1 }","title":"Download"},{"location":"#inspiration","text":"Formula would not have been possible without ideas from other projects such as Elm Cycle.js React / Redux Mobius Square Workflows","title":"Inspiration"},{"location":"#license","text":"The Clear BSD License Copyright (c) 2019 Maplebear Inc. dba Instacart All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted (subject to the limitations in the disclaimer below) provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of Maplebear Inc. dba Instacart nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY S PATENT RIGHTS ARE GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"Integration/","text":"Formula Android The Android module provides a declarative API to connect reactive state management to Android Fragments. This module has been designed for gradual adoption. You can use as much or as little of it as you like. Some of the goals for this module are: - Use single RxJava stream to drive the UI. - Separate state management from Android UI lifecycle. - Ability to group multiple fragments into a flow and share state between them. - Type-safe and scoped fragment event handling. (Avoid casting activity to a listener) Getting Started For the getting started guide, we will build a timer which you can reset. This is a simple example, but it will be sufficient to display some of the concepts around this module. Defining the render model When working with Formula, usually the first thing we define is what our UI will be rendering and what actions it will perform. Render Model is a class that defines this. class TimerRenderModel ( val time : String , val onResetSelected : () - Unit ) Let's apply this render model to android views We define a fragment contract for how a render model is applied to Android views. // Fragment contract has to provide Parcelable implementation because it is passed to the fragment as an argument. // Read more about Parcelize: https://kotlinlang.org/docs/tutorials/android-plugin.html @Parcelize data class TimerContract ( override val tag : String = timer , override val layoutId : Int = R . layout . timer ) : FragmentContract TimerRenderModel () { // A layout is automatically inflated and the view is passed to this callback. override fun createComponent ( view : View ): FragmentComponent TimerRenderModel { val timerTextView = view . findViewById ( R . id . timer_text_view ) val resetButton = view . findViewById ( R . id . timer_reset_button ) return FragmentComponent . create { renderModel - timerTextView . text = renderModel . time resetButton . setOnClickListener { renderModel . onResetSelected () } } } } Register state management for this screen Fragment contract is used as a navigation destination key. For each of the fragment contract types, we provide a state management factory. This factory has to return an Observable RenderModel . The factory will be invoked when the user enters this destination. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { store { // Bind function provides type safety - given a TimerContract, // it expects Observable TimerRenderModel from the factory bind ( TimerContract :: class ) { _ , contract - val resetRelay = PublishRelay . create Unit () resetRelay . startWith ( Unit ). switchMap { Observable . interval ( 0 , 1 , TimeUnit . SECONDS ) . observeOn ( AndroidSchedulers . mainThread ()) } . map { TimerRenderModel ( time = $it seconds passed. , onResetSelected = { resetRelay . accept ( Unit ) } ) } } } } } } } For the sake of simplicity, I've inlined the state management logic into the bind function. In a real world example, this logic would live within Formula . The only thing left is navigating to this screen class MyActivity : FormulaAppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . my_activity ) if ( savedInstanceState == null ) { val contract = TimerContract () val fragment = FormulaFragment . newInstance ( contract ) // Add the fragment using the fragment transaction API. supportFragmentManager . beginTransaction () . add ( R . id . activity_content , fragment , contract . tag ) . commit () } } } If your Activity has another base class, you can just copy logic from FormulaAppCompatActivity into your Activity . And that's it Formula takes care of the rest. The RxJava state stream is instantiated and subscribed to when the user enters declared navigation destination. We dispose of the stream only when user exits the destination. How to pass arguments such as item id to the fragment? Arguments can be passed using the Fragment contract. @Parcelize data class ItemDetailContract ( val itemId : Int , override val tag : String = item detail ${itemId} , override val layoutId : Int = R . layout . item_detail ) : FragmentContract RenderModelType () { override fun createComponent ( view : View ): FragmentComponent RenderModelType { return TODO () } } The contract is passed to the function that instantiates the state management val store = FragmentFlowStore . init { bind ( ItemDetailContract :: class ) { _ , key : ItemDetailContract - // do something with the item id key . itemId } } Fragment Event Handling In fragments, a common pattern for passing events to the parent is casting Activity into a Listener class MyFragment : Fragment () { override fun onAttach ( context : Context ) { listener = context as Listener } override fun onDetach ( context : Context ) { listener = null } } Instead of a listener with methods, we define a sealed class of possible actions that activity can perform. sealed class MyActivityEffect { class ShowToast ( val message : String ): MyActivityEffect () class CloseFragment ( val tag : String ): MyActivityEffect () } class MyActivity : FragmentActivity () { fun onActivityEffect ( effect : MyActivityEffect ) { when ( effect ) { is ShowToast - { Toast . makeText ( this , effect . message , Toast . LENGTH_LONG ). show (); } is CloseFragment - { supportFragmentManager . popBackStack () } } } } We can then use send to trigger this effect. If the activity is not connected, it will do nothing. activity ( MyActivity :: class ) { store { bind ( ItemDetailContract :: class ) { _ , contract - val input = ItemDetailFormula . Input ( onItemFavorited = { send { onActivityEffect ( MyActivityEffect . ShowToast ( Item was added to your favorites. )) } }, onItemDeleted = { send { onActivityEffect ( MyActivityEffect . CloseFragment ( contract . tag )) } } ) val formula : ItemDetailFormula = component . createItemDetailFormula () formula . start ( input ) } } } Navigation To trigger navigation from one screen to another, we add a new type to the MyActivityEffect sealed class. sealed class MyActivityEffect { ... class NavigateToFragmentContract ( val contract : FragmentContract * ): MyActivityEffect () } Now, we can trigger it from event callback such as onItemSelected activity ( MyActivity :: class ) { store { bind ( ItemListContract :: class ) { _ , contract - // Provide callbacks to item list feature events. val input = ItemListFormula . Input ( onItemSelected = { item - val contract = ItemDetailContract ( id = item . id ) send { onActivityEffect ( ActivityEffect . NavigateToFragmentContract ( contract )) } } ) // Hook up the formula state management val formula : ItemListFormula = ... formula . start ( input ) } } } In our activity, we can react to this effect and perform the navigation class MyActivity : FormulaAppCompatActivity () { fun onActivityEffect ( effect : MyActivityEffect ) { when ( effect ) { is NavigateToFragmentContract - { // Perform navigation using fragment transaction val fragment = FormulaFragment . newInstance ( effect . contract ) supportFragmentManager . beginTransaction () . replace ( R . id . fragment_container , fragment , effect . contract . tag ) . addToBackStack ( null ) . commit () } } } } Grouping multiple navigation destinations as part of a flow. Flow is a combination of screens that are grouped together and can share a common component / state. class MyFlowDeclaration : FlowDeclaration MyFlowDeclaration . Component () { // Define the shared component for the flow class Component ( val sharedService : MyFlowService , val onSomeEvent : () - Unit ) override fun createFlow (): Flow Component { return build { bind ( Contract1 :: class ) { component , contract - TODO ( return an RxJava state stream that drives the UI ) } bind ( Contract2 :: class ) { component , contract - TODO ( return an RxJava state stream that drives the UI ) } } } } Moving integration into a separate class When you reach a certain number of fragment integrations, the store creation logic can become unwieldy. To keep it tidy, you can place integration logic into separate class. object TaskDetailIntegration : Integration TaskAppComponent , TaskDetailContract , TaskDetailRenderModel () { override fun create ( component : TaskAppComponent , key : TaskDetailContract ): Observable TaskDetailRenderModel { return component . taskRepo . findTask ( taskId ). map { task - TaskDetailRenderModel ( description = task . description , onDeleteSelected = { component . taskRepo . delete ( taskId ) } ) } } } Now we can update our store to use this integration. val store = FragmentFlowStore . init ( taskAppComponent ) { bind ( TaskDetailIntegration ) // Other integrations. bind ( Contract1Integration ) bind ( Contract2Integration ) } Handling back button events To override how the back button works for a particular navigation destination, your render model needs to implement BackCallback interface. data class FormRenderModel ( private val confirmBeforeExiting : Boolean , private val confirmUserWantsToExit : () - Unit ): BackCallback { fun onBackPressed (): Boolean { // Check if we need to override back handling if ( confirmBeforeExiting ) { confirmUserWantsToExit () return true } // Use default behavior (which closes the screen) return false } } Your Activity needs to call FormulaAndroid.onBackPressed() . It will check if your current screen implements BackCallback and will invoke it. class MyActivity : FragmentActivity () { override fun onBackPressed () { if (! FormulaAndroid . onBackPressed ( this )) { super . onBackPressed () } } } This is already in place for you if you use FormulaAppCompatActivity . Activity state management One of the goals of Formula is to make doing the right thing easy. As part of that we wanted to provide an easy way for state streams to survive configuration changes by default. Let's define a basic activity that has a renderTime method. class MyActivity : FormulaAppCompatActivity () { fun renderTime ( time : String ) { // implementation left to the reader } } To connect an RxJava Observable to renderTime , we define streams parameter which expects a Disposable back. Within this method you can subscribe to any number of RxJava streams. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity MyActivity { store ( streams = { // You can subscribe to your RxJava streams here. val timerState = Observable . interval ( 0 , 1 , TimeUnit . SECONDS ) . observeOn ( AndroidSchedulers . mainThread ()) . map { time - $time seconds } // update ensures that if configuration changes happen then // we send the last state to the new activity instance. update ( timerState , MyActivity :: renderTime ) } ) } } } } You might be confused about the update function called there. It is provided within the context of streams function using Kotlin receiver parameter StreamConfigurator . The update function ensures that state changes only arrive after Activity has started and that last state is applied if Activity is re-created due to configuration changes. It returns a Disposable . Managing dependencies Managing dependencies in Formula is very easy. In the function that instantiates the ActivityStore for your activity, you can create your activity specific dependencies or Dagger components. These objects will survive configuration changes. class MyApp : Application () { override fun onCreate () { super . onCreate () val appComponent : AppComponent = ... FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { // This component will survive configuration changes. val activityComponent = appComponent . createMyActivityComponent () store { } } } } } To inject the activity or create activity dependencies that don't survive configuration changes such as ones that need direct activity reference, you can use configureActivity callback. val appComponent : AppComponent = ... FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { // This component will survive configuration changes. val activityComponent = appComponent . createMyActivityComponent () store ( configureActivity = { // in this callback `this` is the instance of MyActivity // so we can use it to inject dependencies activityComponent . inject ( this ) // Or you can use setters to provide dependencies to your activity. // This dependency object won t survive configuration changes. val dependency = MyActivityDependency ( activity = this ) this . setDependency ( dependency ) } ) } }","title":"Formula Android"},{"location":"Integration/#formula-android","text":"The Android module provides a declarative API to connect reactive state management to Android Fragments. This module has been designed for gradual adoption. You can use as much or as little of it as you like. Some of the goals for this module are: - Use single RxJava stream to drive the UI. - Separate state management from Android UI lifecycle. - Ability to group multiple fragments into a flow and share state between them. - Type-safe and scoped fragment event handling. (Avoid casting activity to a listener)","title":"Formula Android"},{"location":"Integration/#getting-started","text":"For the getting started guide, we will build a timer which you can reset. This is a simple example, but it will be sufficient to display some of the concepts around this module.","title":"Getting Started"},{"location":"Integration/#defining-the-render-model","text":"When working with Formula, usually the first thing we define is what our UI will be rendering and what actions it will perform. Render Model is a class that defines this. class TimerRenderModel ( val time : String , val onResetSelected : () - Unit )","title":"Defining the render model"},{"location":"Integration/#lets-apply-this-render-model-to-android-views","text":"We define a fragment contract for how a render model is applied to Android views. // Fragment contract has to provide Parcelable implementation because it is passed to the fragment as an argument. // Read more about Parcelize: https://kotlinlang.org/docs/tutorials/android-plugin.html @Parcelize data class TimerContract ( override val tag : String = timer , override val layoutId : Int = R . layout . timer ) : FragmentContract TimerRenderModel () { // A layout is automatically inflated and the view is passed to this callback. override fun createComponent ( view : View ): FragmentComponent TimerRenderModel { val timerTextView = view . findViewById ( R . id . timer_text_view ) val resetButton = view . findViewById ( R . id . timer_reset_button ) return FragmentComponent . create { renderModel - timerTextView . text = renderModel . time resetButton . setOnClickListener { renderModel . onResetSelected () } } } }","title":"Let's apply this render model to android views"},{"location":"Integration/#register-state-management-for-this-screen","text":"Fragment contract is used as a navigation destination key. For each of the fragment contract types, we provide a state management factory. This factory has to return an Observable RenderModel . The factory will be invoked when the user enters this destination. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { store { // Bind function provides type safety - given a TimerContract, // it expects Observable TimerRenderModel from the factory bind ( TimerContract :: class ) { _ , contract - val resetRelay = PublishRelay . create Unit () resetRelay . startWith ( Unit ). switchMap { Observable . interval ( 0 , 1 , TimeUnit . SECONDS ) . observeOn ( AndroidSchedulers . mainThread ()) } . map { TimerRenderModel ( time = $it seconds passed. , onResetSelected = { resetRelay . accept ( Unit ) } ) } } } } } } } For the sake of simplicity, I've inlined the state management logic into the bind function. In a real world example, this logic would live within Formula .","title":"Register state management for this screen"},{"location":"Integration/#the-only-thing-left-is-navigating-to-this-screen","text":"class MyActivity : FormulaAppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . my_activity ) if ( savedInstanceState == null ) { val contract = TimerContract () val fragment = FormulaFragment . newInstance ( contract ) // Add the fragment using the fragment transaction API. supportFragmentManager . beginTransaction () . add ( R . id . activity_content , fragment , contract . tag ) . commit () } } } If your Activity has another base class, you can just copy logic from FormulaAppCompatActivity into your Activity .","title":"The only thing left is navigating to this screen"},{"location":"Integration/#and-thats-it","text":"Formula takes care of the rest. The RxJava state stream is instantiated and subscribed to when the user enters declared navigation destination. We dispose of the stream only when user exits the destination.","title":"And that's it"},{"location":"Integration/#how-to-pass-arguments-such-as-item-id-to-the-fragment","text":"Arguments can be passed using the Fragment contract. @Parcelize data class ItemDetailContract ( val itemId : Int , override val tag : String = item detail ${itemId} , override val layoutId : Int = R . layout . item_detail ) : FragmentContract RenderModelType () { override fun createComponent ( view : View ): FragmentComponent RenderModelType { return TODO () } } The contract is passed to the function that instantiates the state management val store = FragmentFlowStore . init { bind ( ItemDetailContract :: class ) { _ , key : ItemDetailContract - // do something with the item id key . itemId } }","title":"How to pass arguments such as item id to the fragment?"},{"location":"Integration/#fragment-event-handling","text":"In fragments, a common pattern for passing events to the parent is casting Activity into a Listener class MyFragment : Fragment () { override fun onAttach ( context : Context ) { listener = context as Listener } override fun onDetach ( context : Context ) { listener = null } } Instead of a listener with methods, we define a sealed class of possible actions that activity can perform. sealed class MyActivityEffect { class ShowToast ( val message : String ): MyActivityEffect () class CloseFragment ( val tag : String ): MyActivityEffect () } class MyActivity : FragmentActivity () { fun onActivityEffect ( effect : MyActivityEffect ) { when ( effect ) { is ShowToast - { Toast . makeText ( this , effect . message , Toast . LENGTH_LONG ). show (); } is CloseFragment - { supportFragmentManager . popBackStack () } } } } We can then use send to trigger this effect. If the activity is not connected, it will do nothing. activity ( MyActivity :: class ) { store { bind ( ItemDetailContract :: class ) { _ , contract - val input = ItemDetailFormula . Input ( onItemFavorited = { send { onActivityEffect ( MyActivityEffect . ShowToast ( Item was added to your favorites. )) } }, onItemDeleted = { send { onActivityEffect ( MyActivityEffect . CloseFragment ( contract . tag )) } } ) val formula : ItemDetailFormula = component . createItemDetailFormula () formula . start ( input ) } } }","title":"Fragment Event Handling"},{"location":"Integration/#navigation","text":"To trigger navigation from one screen to another, we add a new type to the MyActivityEffect sealed class. sealed class MyActivityEffect { ... class NavigateToFragmentContract ( val contract : FragmentContract * ): MyActivityEffect () } Now, we can trigger it from event callback such as onItemSelected activity ( MyActivity :: class ) { store { bind ( ItemListContract :: class ) { _ , contract - // Provide callbacks to item list feature events. val input = ItemListFormula . Input ( onItemSelected = { item - val contract = ItemDetailContract ( id = item . id ) send { onActivityEffect ( ActivityEffect . NavigateToFragmentContract ( contract )) } } ) // Hook up the formula state management val formula : ItemListFormula = ... formula . start ( input ) } } } In our activity, we can react to this effect and perform the navigation class MyActivity : FormulaAppCompatActivity () { fun onActivityEffect ( effect : MyActivityEffect ) { when ( effect ) { is NavigateToFragmentContract - { // Perform navigation using fragment transaction val fragment = FormulaFragment . newInstance ( effect . contract ) supportFragmentManager . beginTransaction () . replace ( R . id . fragment_container , fragment , effect . contract . tag ) . addToBackStack ( null ) . commit () } } } }","title":"Navigation"},{"location":"Integration/#grouping-multiple-navigation-destinations-as-part-of-a-flow","text":"Flow is a combination of screens that are grouped together and can share a common component / state. class MyFlowDeclaration : FlowDeclaration MyFlowDeclaration . Component () { // Define the shared component for the flow class Component ( val sharedService : MyFlowService , val onSomeEvent : () - Unit ) override fun createFlow (): Flow Component { return build { bind ( Contract1 :: class ) { component , contract - TODO ( return an RxJava state stream that drives the UI ) } bind ( Contract2 :: class ) { component , contract - TODO ( return an RxJava state stream that drives the UI ) } } } }","title":"Grouping multiple navigation destinations as part of a flow."},{"location":"Integration/#moving-integration-into-a-separate-class","text":"When you reach a certain number of fragment integrations, the store creation logic can become unwieldy. To keep it tidy, you can place integration logic into separate class. object TaskDetailIntegration : Integration TaskAppComponent , TaskDetailContract , TaskDetailRenderModel () { override fun create ( component : TaskAppComponent , key : TaskDetailContract ): Observable TaskDetailRenderModel { return component . taskRepo . findTask ( taskId ). map { task - TaskDetailRenderModel ( description = task . description , onDeleteSelected = { component . taskRepo . delete ( taskId ) } ) } } } Now we can update our store to use this integration. val store = FragmentFlowStore . init ( taskAppComponent ) { bind ( TaskDetailIntegration ) // Other integrations. bind ( Contract1Integration ) bind ( Contract2Integration ) }","title":"Moving integration into a separate class"},{"location":"Integration/#handling-back-button-events","text":"To override how the back button works for a particular navigation destination, your render model needs to implement BackCallback interface. data class FormRenderModel ( private val confirmBeforeExiting : Boolean , private val confirmUserWantsToExit : () - Unit ): BackCallback { fun onBackPressed (): Boolean { // Check if we need to override back handling if ( confirmBeforeExiting ) { confirmUserWantsToExit () return true } // Use default behavior (which closes the screen) return false } } Your Activity needs to call FormulaAndroid.onBackPressed() . It will check if your current screen implements BackCallback and will invoke it. class MyActivity : FragmentActivity () { override fun onBackPressed () { if (! FormulaAndroid . onBackPressed ( this )) { super . onBackPressed () } } } This is already in place for you if you use FormulaAppCompatActivity .","title":"Handling back button events"},{"location":"Integration/#activity-state-management","text":"One of the goals of Formula is to make doing the right thing easy. As part of that we wanted to provide an easy way for state streams to survive configuration changes by default. Let's define a basic activity that has a renderTime method. class MyActivity : FormulaAppCompatActivity () { fun renderTime ( time : String ) { // implementation left to the reader } } To connect an RxJava Observable to renderTime , we define streams parameter which expects a Disposable back. Within this method you can subscribe to any number of RxJava streams. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity MyActivity { store ( streams = { // You can subscribe to your RxJava streams here. val timerState = Observable . interval ( 0 , 1 , TimeUnit . SECONDS ) . observeOn ( AndroidSchedulers . mainThread ()) . map { time - $time seconds } // update ensures that if configuration changes happen then // we send the last state to the new activity instance. update ( timerState , MyActivity :: renderTime ) } ) } } } } You might be confused about the update function called there. It is provided within the context of streams function using Kotlin receiver parameter StreamConfigurator . The update function ensures that state changes only arrive after Activity has started and that last state is applied if Activity is re-created due to configuration changes. It returns a Disposable .","title":"Activity state management"},{"location":"Integration/#managing-dependencies","text":"Managing dependencies in Formula is very easy. In the function that instantiates the ActivityStore for your activity, you can create your activity specific dependencies or Dagger components. These objects will survive configuration changes. class MyApp : Application () { override fun onCreate () { super . onCreate () val appComponent : AppComponent = ... FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { // This component will survive configuration changes. val activityComponent = appComponent . createMyActivityComponent () store { } } } } } To inject the activity or create activity dependencies that don't survive configuration changes such as ones that need direct activity reference, you can use configureActivity callback. val appComponent : AppComponent = ... FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { // This component will survive configuration changes. val activityComponent = appComponent . createMyActivityComponent () store ( configureActivity = { // in this callback `this` is the instance of MyActivity // so we can use it to inject dependencies activityComponent . inject ( this ) // Or you can use setters to provide dependencies to your activity. // This dependency object won t survive configuration changes. val dependency = MyActivityDependency ( activity = this ) this . setDependency ( dependency ) } ) } }","title":"Managing dependencies"},{"location":"State-Render-Model-Separation/","text":"Why state render model separation This allows us to keep the view very stupid. Let's say we have a state class such as this data class State ( val userInfo : Lce UserInfo , val saveRequest : Lce SaveResponse ? = null ) // UI layer now has to contain logic to process these properties. fun render ( state : State ) { saveButton . isEnabled = state . userInfo . hasData () ( state . saveRequest == null ! state . saveRequest . isLoading ()) } To avoid having such logic in the view, we have created the RenderModel concept. data class RenderModel ( val isSaveEnabled : Boolean ) The logic where we do this transformation is encapsulated in the RenderModelGenerator. class MyRenderModelGenerator : RenderModelGenerator State , RenderModel { override fun toRenderModel ( state : State ): RenderModel { return RenderModel ( isSaveEnabled = state . userInfo . hasData () ( state . saveRequest == null ! state . saveRequest . isLoading ()) ) } } Now, the UI would receive a RenderModel instead of State. Also, we can now easily unit test that logic separately from the view.","title":"State Render Model Separation"},{"location":"State-Render-Model-Separation/#why-state-render-model-separation","text":"This allows us to keep the view very stupid. Let's say we have a state class such as this data class State ( val userInfo : Lce UserInfo , val saveRequest : Lce SaveResponse ? = null ) // UI layer now has to contain logic to process these properties. fun render ( state : State ) { saveButton . isEnabled = state . userInfo . hasData () ( state . saveRequest == null ! state . saveRequest . isLoading ()) } To avoid having such logic in the view, we have created the RenderModel concept. data class RenderModel ( val isSaveEnabled : Boolean ) The logic where we do this transformation is encapsulated in the RenderModelGenerator. class MyRenderModelGenerator : RenderModelGenerator State , RenderModel { override fun toRenderModel ( state : State ): RenderModel { return RenderModel ( isSaveEnabled = state . userInfo . hasData () ( state . saveRequest == null ! state . saveRequest . isLoading ()) ) } } Now, the UI would receive a RenderModel instead of State. Also, we can now easily unit test that logic separately from the view.","title":"Why state &amp; render model separation"},{"location":"async_events/","text":"It's worth reading Event Handling section first given that there is a lot of overlap. To show how Formula handles asynchronous events, we'll use a task app example. Let's say we have a task repository that exposes an RxJava Observable List Task . interface TaskRepo { fun tasks (): Observable List Task } All asynchronous events have to be declared within Formula.evaluate function. override fun evaluate ( input : Input , state : State , context : FormulaContext ): ... { return Evaluation ( renderModel = createRenderModel ( state . taskList ), // All async events need to be declared within context.updates block. updates = context . updates { // Convert RxJava observable to a Formula Stream. val taskStream = RxStream . fromObservable ( taskRepo :: tasks ) // Tell Formula that you want to listen to these events events ( taskStream ) { newTaskList - // update our state transition ( state . copy ( taskList = newTaskList )) } } ) } Formula uses a Stream interface to define an asynchronous event producers/sources. interface Stream Message { fun start ( send : ( Message ) - Unit ): Cancelable ? } In this example we used an RxStream.fromObservable to convert from an Observable to a Stream instance. Instead of us subscribing to the observable/stream directly, the runtime manages the subscriptions for us. It will subscribe the first time events is called and unsubscribe when our Formula is removed or if we don't return it anymore. For example, it is okay to have conditional logic. context . updates { if ( state . locationTrackingEnabled ) { val locationStream = RxStream . fromObservable { locationManager . updates () } events ( locationStream ) { event - transition ( state . copy ( location = event . location )) } } } If state.locationTrackingEnabled changes from true to false , we won't return this Stream anymore and the runtime will unsubscribe. Fetching data Let's say we need to fetch a task that has a specific task id . interface TaskRepo { fun fetchTask ( taskId : String ): Observable Task } Using TaskRepo directly: class TaskFormula ( val taskRepo : TaskRepo ): Formula { data class Input ( val taskId : String ) data class State ( val task : Task ? = null ) override fun evaluate ( input : Input , state : State , context : FormulaContext .. ): Evaluation RenderModel { return Evaluation ( updates = context . updates { val fetchTask = RxStream . fromObservable ( key = input . taskId ) { taskRepo . fetchTask ( input . taskId ) } events ( fetchTask ) { taskResponse - transition ( state . copy ( task = taskResponse )) } } ) } } The key parameter enables us to distinguish between different streams. If input.taskId changes, we will cancel the currently running Stream and start a new one. Note: we are not handling errors in this example. The best practice is to emit errors as data using the onNext instead of emitting them through onError. Extending Stream Interface If you need to use a different mechanism for asynchronous events, you can extend Stream interface. interface Stream Message { fun start ( send : ( Message ) - Unit ): Cancelable ? } For example, let's say we want to track network status (I'm going to use mock network status APIs). class NetworkStatusStream ( val manager : NetworkStatusManager ) : Stream NetworkStatus { override fun start ( send : ( NetworkStatus ) - Unit ): Cancelable ? { val listener = object : NetworkStatusListener { override fun onNetworkStatusChanged ( status : NetworkStatus ) = send ( status ) } manager . addNetworkStatusListener ( listener ) return Cancelable { manager . removeNetworkStatusListener ( listener ) } } } We can now hook this up within our Formula: class MyFormula ( val networkStatus : NetworkStatusStream ): Formula { override fun evaluate ( input : .., state : .., context : FormulaContext ): .. { return Evaluation ( updates = context . updates { events ( networkStatus ) { status - val updated = status . copy ( isOnline = status . isOnline ) transition ( updated ) } } ) } }","title":"Asynchronous Events"},{"location":"async_events/#fetching-data","text":"Let's say we need to fetch a task that has a specific task id . interface TaskRepo { fun fetchTask ( taskId : String ): Observable Task } Using TaskRepo directly: class TaskFormula ( val taskRepo : TaskRepo ): Formula { data class Input ( val taskId : String ) data class State ( val task : Task ? = null ) override fun evaluate ( input : Input , state : State , context : FormulaContext .. ): Evaluation RenderModel { return Evaluation ( updates = context . updates { val fetchTask = RxStream . fromObservable ( key = input . taskId ) { taskRepo . fetchTask ( input . taskId ) } events ( fetchTask ) { taskResponse - transition ( state . copy ( task = taskResponse )) } } ) } } The key parameter enables us to distinguish between different streams. If input.taskId changes, we will cancel the currently running Stream and start a new one. Note: we are not handling errors in this example. The best practice is to emit errors as data using the onNext instead of emitting them through onError.","title":"Fetching data"},{"location":"async_events/#extending-stream-interface","text":"If you need to use a different mechanism for asynchronous events, you can extend Stream interface. interface Stream Message { fun start ( send : ( Message ) - Unit ): Cancelable ? } For example, let's say we want to track network status (I'm going to use mock network status APIs). class NetworkStatusStream ( val manager : NetworkStatusManager ) : Stream NetworkStatus { override fun start ( send : ( NetworkStatus ) - Unit ): Cancelable ? { val listener = object : NetworkStatusListener { override fun onNetworkStatusChanged ( status : NetworkStatus ) = send ( status ) } manager . addNetworkStatusListener ( listener ) return Cancelable { manager . removeNetworkStatusListener ( listener ) } } } We can now hook this up within our Formula: class MyFormula ( val networkStatus : NetworkStatusStream ): Formula { override fun evaluate ( input : .., state : .., context : FormulaContext ): .. { return Evaluation ( updates = context . updates { events ( networkStatus ) { status - val updated = status . copy ( isOnline = status . isOnline ) transition ( updated ) } } ) } }","title":"Extending Stream Interface"},{"location":"composition/","text":"Composing Render models Render Models are meant to be composable. You can build bigger Render Models from smaller Render Models. data class CheckboxRenderModel ( val text : String , val isChecked : Boolean , val onToggle : () - Unit ) data class NotificationSettingsRenderModel ( val messagePushNotification : CheckboxRenderModel , val promotionalPushNotifications : CheckboxRenderModel , val marketingEmailNotifications : CheckboxRenderModel , val saveSettingsButton : FooterButtonRenderModel ) You can also do the same in your Render View layer. class CheckboxRenderView ( root : View ) : RenderView CheckboxRenderModel { private val checkbox : Checkbox = root . findViewById ( R . id . checkbox ) override val renderer : Renderer CheckboxRenderModel = Renderer . create { model - checkbox . text = model . title checkbox . isChecked = model . isChecked checkbox . setOnCheckedListener { model . onToggle () } } } class NotificationSettingsRenderView ( root : View ) : RenderView NotificationSettingsRenderModel { private val messagePushNotification = CheckboxRenderView ( root . findViewById ( R . id . message_push_checkbox )) private val promotionalPushNotifications = CheckboxRenderView ( root . findViewById ( R . id . promotional_push_checkbox )) private val marketingEmailNotifications = CheckboxRenderView ( root . findViewById ( R . id . marketing_email_checkbox )) private val saveButton = FooterButtonRenderView ( root . findViewById ( R . id . save_button )) override val renderer : Renderer NotificationSettingsRenderModel = Renderer . create { model - messagePushNotification . renderer . render ( model . messagePushNotification ) promotionalPushNotifications . renderer . render ( model . promotionalPushNotifications ) marketingEmailNotifications . renderer . render ( model . marketingEmailNotifications ) saveButton . renderer . render ( model . saveSettingsButton ) } } Composing formulas You can pass other formulas through the constructor class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula Use FormulaContext.child within Formula.evaluate to hook them up. val listRenderModel = context . child ( listFormula ) . input { ListInput ( items = state . items , onItemSelected = context . eventCallback { // you can respond to child event } } Here is a more complete example: class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula { override fun evaluate ( input : Unit , state : MyState , context : FormulaContext ... ): Evaluation ... { // context.child returns a RenderModel val listRenderModel = context . child ( listFormula ) . input { createListInput ( state ) } val headerRenderModel = context . child ( headerFormula ) . input { createHeaderInput ( state ) } // We can make decisions using the current `state` about // what children to show val dialog = if ( state . showDialog ) { context . child ( dialogFormula ) . input ( Unit ) } else { null } return Evaluation ( renderModel = MainRenderModel ( header = headerRenderModel , list = listRenderModel , dialog = dialog ) ) } }","title":"Composition"},{"location":"composition/#composing-render-models","text":"Render Models are meant to be composable. You can build bigger Render Models from smaller Render Models. data class CheckboxRenderModel ( val text : String , val isChecked : Boolean , val onToggle : () - Unit ) data class NotificationSettingsRenderModel ( val messagePushNotification : CheckboxRenderModel , val promotionalPushNotifications : CheckboxRenderModel , val marketingEmailNotifications : CheckboxRenderModel , val saveSettingsButton : FooterButtonRenderModel ) You can also do the same in your Render View layer. class CheckboxRenderView ( root : View ) : RenderView CheckboxRenderModel { private val checkbox : Checkbox = root . findViewById ( R . id . checkbox ) override val renderer : Renderer CheckboxRenderModel = Renderer . create { model - checkbox . text = model . title checkbox . isChecked = model . isChecked checkbox . setOnCheckedListener { model . onToggle () } } } class NotificationSettingsRenderView ( root : View ) : RenderView NotificationSettingsRenderModel { private val messagePushNotification = CheckboxRenderView ( root . findViewById ( R . id . message_push_checkbox )) private val promotionalPushNotifications = CheckboxRenderView ( root . findViewById ( R . id . promotional_push_checkbox )) private val marketingEmailNotifications = CheckboxRenderView ( root . findViewById ( R . id . marketing_email_checkbox )) private val saveButton = FooterButtonRenderView ( root . findViewById ( R . id . save_button )) override val renderer : Renderer NotificationSettingsRenderModel = Renderer . create { model - messagePushNotification . renderer . render ( model . messagePushNotification ) promotionalPushNotifications . renderer . render ( model . promotionalPushNotifications ) marketingEmailNotifications . renderer . render ( model . marketingEmailNotifications ) saveButton . renderer . render ( model . saveSettingsButton ) } }","title":"Composing Render models"},{"location":"composition/#composing-formulas","text":"You can pass other formulas through the constructor class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula Use FormulaContext.child within Formula.evaluate to hook them up. val listRenderModel = context . child ( listFormula ) . input { ListInput ( items = state . items , onItemSelected = context . eventCallback { // you can respond to child event } } Here is a more complete example: class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula { override fun evaluate ( input : Unit , state : MyState , context : FormulaContext ... ): Evaluation ... { // context.child returns a RenderModel val listRenderModel = context . child ( listFormula ) . input { createListInput ( state ) } val headerRenderModel = context . child ( headerFormula ) . input { createHeaderInput ( state ) } // We can make decisions using the current `state` about // what children to show val dialog = if ( state . showDialog ) { context . child ( dialogFormula ) . input ( Unit ) } else { null } return Evaluation ( renderModel = MainRenderModel ( header = headerRenderModel , list = listRenderModel , dialog = dialog ) ) } }","title":"Composing formulas"},{"location":"contributing/","text":"TODO...","title":"Contributing"},{"location":"diffing/","text":"TODO Diffing Given that we recompute everything with each state change, there is an internal diffing mechanism with Formula. This mechanism ensures that: 1. RxJava streams are only subscribed to once. 2. Children state is persisted across every processing pass.","title":"Diffing"},{"location":"diffing/#diffing","text":"Given that we recompute everything with each state change, there is an internal diffing mechanism with Formula. This mechanism ensures that: 1. RxJava streams are only subscribed to once. 2. Children state is persisted across every processing pass.","title":"Diffing"},{"location":"events/","text":"Event handling in Formula is based on simple callback functions. Callbacks can have zero or one parameter to pass data as part of the event. UI Events To handle UI events, declare a function on the Render Model for each type of UI event you care about. data class FormRenderModel ( // A callback with no parameters val onSaveSelected : () - Unit , // A callback where data is passed as part of the event. val onNameChanged : ( newName : String ) - Unit ) All callbacks should be created within Formula.evaluate block. override fun evaluate ( input : Input , state : State , context : FormulaContext ): ... { return Evaluation ( renderModel = FormRenderModel ( // Use FormulaContext.eventCallback for callbacks that have a parameter. onNameChanged = context . eventCallback { newName - // Use newName to perform a transition transition ( state . copy ( name = newName )) }, // Use FormulaContext.callback for callbacks with no parameters. onSaveSelected = context . callback { // No state change, performing side-effects. transition { userService . updateName ( state . name ) analytics . trackNameUpdated ( state . name ) } } ) ) } This example is dense, but it shows almost every kind of scenario. Let's go over it. To create a callback, we pass a function that returns a Transition State . Formula uses transitions to update internal state and/or perform side-effects to other components. Callbacks are scoped to the current state. Any time we transition to a new state, evaluate is called again and the callbacks are recreated. // Updating state context . eventCallback { newName : String - // We use kotlin data class copy function // to create a new state with new name transition ( state . copy ( name = newName )) } // Updating onSaveSelected to include validation context . callback { if ( state . name . isBlank ()) { // A transition which performs a side-effect. transition { input . showNotification ( Name cannot be empty! ) } } else { // No state change, performing side-effects as part of the transition transition { userService . updateName ( state . name ) analytics . trackNameUpdated ( state . name ) } } } To ensure safe execution, all side-effects should be performed within transition {} block which will be executed after the state change is performed. Sending messages to the parent To pass events to the parent, first define the callbacks on the Formula.Input class. data class ItemListInput ( val onItemSelected : ( itemId : String ) - Unit ) Also, lets make sure that Input type is declared at the top of our formula . class ItemListFormula () : Formula ItemListInput , ..., ... Now, we can use the input passed to us in Formula.evaluate to communicate with the parent. override fun evaluate ( input : ItemListInput , state , context ): ... { return Evaluation ( renderModel = state . items . map { item - context . key ( item . id ) { ItemRow ( name = item . name , onClick = context . callback { // Notifying parent that item was selected. transition { input . onItemSelected ( item . id ) } } ) } } ) } Formula events There are a few events that every formula can listen to and respond. Evaluation ( renderModel = ..., updates = context . updates { // Performs a side effect when formula is initialized events ( Stream . onInit ()) { transition { analytics . trackScreenOpen () } } // Performs a side effect when formula is terminated events ( Stream . onTerminate ()) { transition { analytics . trackClose () } } // Performs a side-effect when data changes events ( Stream . onData (), state . itemId ) { // This will call api.fetchItem for each unique itemId transition { api . fetchItem ( state . itemId ) } } } ) Formula retains callbacks Callbacks retain equality across re-evaluation (such as state changes). The first time formula requests a callback, we create it and persist it in the map. Subsequent calls will re-use this instance. The instance is disabled and removed when your formula is removed or if you don't request this callback within Formula.evaluate block. By default, we generate a key for each callback based on the position in code where it is called. There are a couple of cases when this is not sufficient and you need to explicitly provide a unique key . Case 1: Declaring callbacks within a loop For example, if you are mapping list of items and creating a callback within the map function. // This will not work unless your list of items never changes (removal of item or position change). ItemListRenderModel ( items = state . items . map { item - ItemRenderModel ( name = item . name , onSelected = context . callback { // perform a transition } ) } ) To fix it, you should wrap ItemRenderModel creation block in context.key where you pass it an item id . context . key ( item . id ) { ItemRenderModel ( name = item . name , onSelected = context . callback { // perform a transition } ) } Case 2: Delegating to another function There is an issue with callbacks when passing FormulaContext to another function. Let's say you have a function that takes FormulaContext and creates a ChildRenderModel. fun createChildRenderModel ( context : FormulaContext ... ): ChildRenderModel { return ChildRenderModel ( onClick = context . callback {} ) } There is no problem calling it once, but there will be key collisions if you call it multiple times: RenderModel ( // First child is created with no problem first = createChildRenderModel ( context ), // Calling it again will crash second = createChildRenderModel ( context ) ) To fix it, wrap createChildRenderModel with context.key block. RenderModel ( first = context . key ( first ) { createChildRenderModel ( context ) }, second = context . key ( second ) { createChildRenderModel ( context ) } )","title":"Event Handling"},{"location":"events/#ui-events","text":"To handle UI events, declare a function on the Render Model for each type of UI event you care about. data class FormRenderModel ( // A callback with no parameters val onSaveSelected : () - Unit , // A callback where data is passed as part of the event. val onNameChanged : ( newName : String ) - Unit ) All callbacks should be created within Formula.evaluate block. override fun evaluate ( input : Input , state : State , context : FormulaContext ): ... { return Evaluation ( renderModel = FormRenderModel ( // Use FormulaContext.eventCallback for callbacks that have a parameter. onNameChanged = context . eventCallback { newName - // Use newName to perform a transition transition ( state . copy ( name = newName )) }, // Use FormulaContext.callback for callbacks with no parameters. onSaveSelected = context . callback { // No state change, performing side-effects. transition { userService . updateName ( state . name ) analytics . trackNameUpdated ( state . name ) } } ) ) } This example is dense, but it shows almost every kind of scenario. Let's go over it. To create a callback, we pass a function that returns a Transition State . Formula uses transitions to update internal state and/or perform side-effects to other components. Callbacks are scoped to the current state. Any time we transition to a new state, evaluate is called again and the callbacks are recreated. // Updating state context . eventCallback { newName : String - // We use kotlin data class copy function // to create a new state with new name transition ( state . copy ( name = newName )) } // Updating onSaveSelected to include validation context . callback { if ( state . name . isBlank ()) { // A transition which performs a side-effect. transition { input . showNotification ( Name cannot be empty! ) } } else { // No state change, performing side-effects as part of the transition transition { userService . updateName ( state . name ) analytics . trackNameUpdated ( state . name ) } } } To ensure safe execution, all side-effects should be performed within transition {} block which will be executed after the state change is performed.","title":"UI Events"},{"location":"events/#sending-messages-to-the-parent","text":"To pass events to the parent, first define the callbacks on the Formula.Input class. data class ItemListInput ( val onItemSelected : ( itemId : String ) - Unit ) Also, lets make sure that Input type is declared at the top of our formula . class ItemListFormula () : Formula ItemListInput , ..., ... Now, we can use the input passed to us in Formula.evaluate to communicate with the parent. override fun evaluate ( input : ItemListInput , state , context ): ... { return Evaluation ( renderModel = state . items . map { item - context . key ( item . id ) { ItemRow ( name = item . name , onClick = context . callback { // Notifying parent that item was selected. transition { input . onItemSelected ( item . id ) } } ) } } ) }","title":"Sending messages to the parent"},{"location":"events/#formula-events","text":"There are a few events that every formula can listen to and respond. Evaluation ( renderModel = ..., updates = context . updates { // Performs a side effect when formula is initialized events ( Stream . onInit ()) { transition { analytics . trackScreenOpen () } } // Performs a side effect when formula is terminated events ( Stream . onTerminate ()) { transition { analytics . trackClose () } } // Performs a side-effect when data changes events ( Stream . onData (), state . itemId ) { // This will call api.fetchItem for each unique itemId transition { api . fetchItem ( state . itemId ) } } } )","title":"Formula events"},{"location":"events/#formula-retains-callbacks","text":"Callbacks retain equality across re-evaluation (such as state changes). The first time formula requests a callback, we create it and persist it in the map. Subsequent calls will re-use this instance. The instance is disabled and removed when your formula is removed or if you don't request this callback within Formula.evaluate block. By default, we generate a key for each callback based on the position in code where it is called. There are a couple of cases when this is not sufficient and you need to explicitly provide a unique key .","title":"Formula retains callbacks"},{"location":"events/#case-1-declaring-callbacks-within-a-loop","text":"For example, if you are mapping list of items and creating a callback within the map function. // This will not work unless your list of items never changes (removal of item or position change). ItemListRenderModel ( items = state . items . map { item - ItemRenderModel ( name = item . name , onSelected = context . callback { // perform a transition } ) } ) To fix it, you should wrap ItemRenderModel creation block in context.key where you pass it an item id . context . key ( item . id ) { ItemRenderModel ( name = item . name , onSelected = context . callback { // perform a transition } ) }","title":"Case 1: Declaring callbacks within a loop"},{"location":"events/#case-2-delegating-to-another-function","text":"There is an issue with callbacks when passing FormulaContext to another function. Let's say you have a function that takes FormulaContext and creates a ChildRenderModel. fun createChildRenderModel ( context : FormulaContext ... ): ChildRenderModel { return ChildRenderModel ( onClick = context . callback {} ) } There is no problem calling it once, but there will be key collisions if you call it multiple times: RenderModel ( // First child is created with no problem first = createChildRenderModel ( context ), // Calling it again will crash second = createChildRenderModel ( context ) ) To fix it, wrap createChildRenderModel with context.key block. RenderModel ( first = context . key ( first ) { createChildRenderModel ( context ) }, second = context . key ( second ) { createChildRenderModel ( context ) } )","title":"Case 2: Delegating to another function"},{"location":"faq/","text":"Only thread that created it can trigger transitions The state management should be initialized on the main thread and all the transitions should also happen on the main thread. You will get the following exception if that is not the case. Caused by: java.lang.IllegalStateException: Only thread that created it can trigger transitions. Expected: main, Was: Network 1 Transition already happened. After each transition, formula is re-evaluated and new event listeners are created. If you use an old listener you will see the following exception. Caused by: java.lang.IllegalStateException: Transition already happened. This is using old transition callback: $it. Callback is already defined. TODO..","title":"FAQ"},{"location":"faq/#only-thread-that-created-it-can-trigger-transitions","text":"The state management should be initialized on the main thread and all the transitions should also happen on the main thread. You will get the following exception if that is not the case. Caused by: java.lang.IllegalStateException: Only thread that created it can trigger transitions. Expected: main, Was: Network 1","title":"Only thread that created it can trigger transitions"},{"location":"faq/#transition-already-happened","text":"After each transition, formula is re-evaluated and new event listeners are created. If you use an old listener you will see the following exception. Caused by: java.lang.IllegalStateException: Transition already happened. This is using old transition callback: $it.","title":"Transition already happened."},{"location":"faq/#callback-is-already-defined","text":"TODO..","title":"Callback is already defined."},{"location":"input/","text":"Input is a Kotlin data class used to pass data and event callbacks to the Formula instance. Let's say we need to pass an item id to ItemDetailFormula . class ItemDetailFormula () : Formula ItemDetailFormula . Input , ..., ... { // Input declaration data class Input ( val itemId : String ) // Use input to initialize state override fun initialState ( input : Input ): State = ... // Respond to Input changes. override fun onInputChanged ( oldInput : Input , input : Input , state : State ): State { // We can compare old and new inputs and create // a new state before `Formula.evaluate` is called. return state } // Using input within evaluate block override fun evaluate ( input : Input , state : .., context : .. ): Evaluation ... { val itemId = input . itemId // We can use the input here to fetch the item from the repo. } } To pass the input to ItemDetailFormula val itemDetailFormula : ItemDetailFormula = ... itemDetailFormula . start ( ItemDetailFormula . Input ( itemId = 1 )) . subscribe { renderModel - } You could also pass an Observable ItemDetailFormula.Input val itemDetailInput : Observable ItemDetailFormula . Input = ... itemDetailFormula . start ( itemDetailInput ) . subscribe { renderModel - }","title":"Using Input"},{"location":"testing/","text":"To simplify testing your Formulas, you can use formula-test module. testImplementation com.github.instacart:formula-test:{latest_version} Testing the last render model emission val subject = MyFormula (). test (). renderModel { assertThat ( this . name ). isEqualTo ( my name ) } If your Formula has children, you can replace their render model output val subject = MyFormula (). test { // We are using mockito to mock ChildRenderModel. // You could also manually create it. child ( MyChildFormula :: class , mock ChildRenderModel ()) } To inspect the input that was passed to the child subject . childInput ( MyChildFormula :: class ) { assertThat ( this . property ). isEqualTo ( property ) } You can fake child events subject . childInput ( MyChildFormula :: class ) { this . onEvent ( fake data ) }","title":"Testing"},{"location":"using_android_view_model/","text":"Define ViewModel which runs Formula.state stream until onCleared is called. class CounterViewModel () : ViewModel { private val formula = CounterFormula () private val disposables = CompositeDisposable () val renderModels = formula . start (). replay ( 1 ). apply { connect { disposables . add ( it ) } } override fun onCleared () { super . onCleared () disposables . clear () } } In our activity, we then subscribe to the Render Model changes and pass them to the Render View. class MyActivity : AppCompatActivity () { private val disposables = CompositeDisposable () override fun onCreate ( state : Bundle ?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) val renderView = CounterRenderView ( findViewById ( R . id . counter )) val viewModel = ViewModelProviders . of ( this ). get ( CounterViewModel :: class . java ) disposables . add ( viewModel . renderModels . subscribe ( renderView . renderer :: render )) } override fun onDestroy () { disposables . clear () super . onDestroy () } }","title":"Using Android View Model"}]}